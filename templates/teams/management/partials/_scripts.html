    <script>
        // Lucide
        lucide.createIcons();

        // Elements
        const sidebar = document.getElementById('sidebar');
        const scrim = document.getElementById('scrim');
        const openSidebarBtn = document.getElementById('openSidebar');
        const closeSidebarBtn = document.getElementById('closeSidebar');

        const pageTitle = document.getElementById('pageTitle');
        const pageSub = document.getElementById('pageSub');

        const roleChip = document.getElementById('roleChip');
        const gameChip = document.getElementById('gameChip');
        const orgMenuGroup = document.getElementById('orgMenuGroup');

        // Demo controller
        const demoFab = document.getElementById('demoFab');
        const demoPop = document.getElementById('demoPop');
        const demoClose = document.getElementById('demoClose');

        const demoRole = document.getElementById('demoRole');
        const demoGame = document.getElementById('demoGame');

        const demoPrimary = document.getElementById('demoPrimary');
        const demoAccent = document.getElementById('demoAccent');
        const demoPrimaryHex = document.getElementById('demoPrimaryHex');
        const demoAccentHex = document.getElementById('demoAccentHex');
        const demoResetColors = document.getElementById('demoResetColors');

        const qaInvite = document.getElementById('qaInvite');
        const qaAnnounce = document.getElementById('qaAnnounce');

        // Demo flags (used in PART 2 when filling real components)
        const demoFlagReadiness = document.getElementById('demoFlagReadiness');
        const demoFlagLock = document.getElementById('demoFlagLock');
        const demoFlagPending = document.getElementById('demoFlagPending');

        // Route metadata (with search placeholders)
        const ROUTES = {
            command: { title: "Command Center", sub: "Real-time team overview and quick actions", search: "Search events, alerts, actions..." },
            roster: { title: "Roster Ops", sub: "Players & staff, invites, tryouts, roles, locks", search: "Search members, staff, roles..." },
            competition: { title: "Competition Hub", sub: "Tournaments, matches, results, disputes, evidence", search: "Search tournaments, matches..." },
            training: { title: "Training Lab", sub: "Practice, scrims, VOD review, challenges & bounties", search: "Search practices, scrims, VODs..." },
            community: { title: "Community & Media", sub: "Community app spaces, posts, highlights, library", search: "Search posts, highlights, media..." },
            profile: { title: "Team Profile", sub: "Public identity editor & module layout controls", search: "Search profile settings..." },
            settings: { title: "Settings & Security", sub: "Privacy, notifications, access control, audits", search: "Search settings, permissions..." },
            org: { title: "Organization Console", sub: "Org-level governance & verification", search: "Search org teams, staff..." }
        };

        const hqSearchInput = document.getElementById('hqSearch');

        // Helpers
        function openSidebar() {
            sidebar.classList.remove('-translate-x-[110%]');
            scrim.classList.remove('hidden');
        }
        function closeSidebar() {
            sidebar.classList.add('-translate-x-[110%]');
            scrim.classList.add('hidden');
        }

        function setActiveRoute(route) {
            // Switch sections
            document.querySelectorAll('.hq-section').forEach(sec => {
                sec.classList.toggle('is-active', sec.id === route);
            });

            // Switch nav highlight
            document.querySelectorAll('.nav-item').forEach(a => {
                const isActive = a.dataset.route === route;
                if (isActive) a.setAttribute('aria-current', 'page');
                else a.removeAttribute('aria-current');
            });

            // Set header text
            const meta = ROUTES[route] || ROUTES.command;
            pageTitle.textContent = meta.title;
            pageSub.textContent = meta.sub;

            // Update search placeholder (context-aware)
            if (hqSearchInput) {
                hqSearchInput.placeholder = meta.search || 'Search...';
            }

            // Hash
            if (location.hash.replace('#', '') !== route) {
                history.replaceState(null, '', '#' + route);
            }

            // Close on mobile
            if (window.matchMedia('(max-width: 1023px)').matches) {
                closeSidebar();
            }
        }

        // Nav click wiring
        document.querySelectorAll('.nav-item').forEach(a => {
            a.addEventListener('click', (e) => {
                e.preventDefault();
                const route = a.dataset.route;
                setActiveRoute(route);
            });
        });

        // Mobile menu buttons
        openSidebarBtn?.addEventListener('click', openSidebar);
        closeSidebarBtn?.addEventListener('click', closeSidebar);
        scrim?.addEventListener('click', closeSidebar);

        // Quick actions route (demo)
        qaInvite?.addEventListener('click', () => setActiveRoute('roster'));
        qaAnnounce?.addEventListener('click', () => setActiveRoute('community'));

        // Demo popover
        function openDemo() {
            demoPop.dataset.open = "true";
            demoPop.setAttribute('aria-hidden', 'false');
        }
        function closeDemo() {
            demoPop.dataset.open = "false";
            demoPop.setAttribute('aria-hidden', 'true');
        }
        demoFab?.addEventListener('click', () => {
            const open = demoPop.dataset.open === "true";
            open ? closeDemo() : openDemo();
        });
        demoClose?.addEventListener('click', closeDemo);

        // Close demo on Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeSidebar();
                closeDemo();
            }
        });

        // Role gating (UI preview)
        // Role hierarchy for permission checking
        const ROLE_HIERARCHY = {
            'MEMBER': 0,
            'STAFF': 1,
            'OWNER': 2,
            'ORG_ADMIN': 3
        };

        // Check if active role meets permission requirement
        function hasPermission(activeRole, requiredPermission) {
            if (!requiredPermission) return true;

            if (requiredPermission.endsWith('+')) {
                // "STAFF+" means STAFF or higher
                const minRole = requiredPermission.slice(0, -1);
                return ROLE_HIERARCHY[activeRole] >= ROLE_HIERARCHY[minRole];
            } else {
                // Exact match required
                return activeRole === requiredPermission;
            }
        }

        // Apply role-based visibility to all gated elements
        function applyRoleGating(activeRole) {
            document.querySelectorAll('[data-role-gate]').forEach(el => {
                const required = el.dataset.roleGate;
                const visible = hasPermission(activeRole, required);

                if (!visible) {
                    el.style.display = 'none';
                    el.setAttribute('data-locked-reason', `Requires ${required} permission`);
                    el.setAttribute('title', `Requires ${required} permission`);
                } else {
                    el.style.display = '';
                    el.removeAttribute('data-locked-reason');
                    el.removeAttribute('title');
                }
            });
        }

        function applyRole(role) {
            const map = {
                MEMBER: "ðŸ‘¤ Member",
                STAFF: "ðŸ‘” Staff",
                OWNER: "ðŸ‘‘ Owner",
                ORG_ADMIN: "ðŸ¢ Org Admin"
            };
            roleChip.textContent = map[role] || "ðŸ‘¤ Member";

            // Org menu only for ORG_ADMIN
            const showOrg = role === "ORG_ADMIN";
            orgMenuGroup.hidden = !showOrg;

            // If current route is org but role not org admin, bounce to command
            const current = location.hash.replace('#', '') || 'command';
            if (!showOrg && current === 'org') {
                setActiveRoute('command');
            }

            // Apply role-based visibility
            applyRoleGating(role);
        }

        // Security & Abuse Prevention
        const SECURITY = {
            inviteRateLimit: {
                maxInvites: 10, // max invites per hour
                window: 60 * 60 * 1000, // 1 hour in ms
                invites: [] // timestamp array
            },

            // Check if invite action is allowed (rate limiting)
            canInvite: function () {
                const now = Date.now();
                // Remove old invites outside window
                this.inviteRateLimit.invites = this.inviteRateLimit.invites.filter(
                    time => now - time < this.inviteRateLimit.window
                );

                if (this.inviteRateLimit.invites.length >= this.inviteRateLimit.maxInvites) {
                    console.warn('Invite rate limit exceeded');
                    return false;
                }

                return true;
            },

            // Record invite action
            recordInvite: function () {
                this.inviteRateLimit.invites.push(Date.now());
            },

            // Check role escalation protection
            canGrantRole: function (granterRole, targetRole) {
                const granterLevel = ROLE_HIERARCHY[granterRole] || 0;
                const targetLevel = ROLE_HIERARCHY[targetRole] || 0;

                // Cannot grant role equal or higher than own
                if (targetLevel >= granterLevel) {
                    console.warn(`Role escalation blocked: ${granterRole} cannot grant ${targetRole}`);
                    return false;
                }

                // Only Owner can grant Owner
                if (targetRole === 'OWNER' && granterRole !== 'OWNER') {
                    console.warn('Only Owner can grant Owner role');
                    return false;
                }

                return true;
            },

            // Log audit event (placeholder - would send to backend)
            logAudit: function (action, details) {
                const entry = {
                    timestamp: new Date().toISOString(),
                    action: action,
                    details: details,
                    user: roleChip.textContent // current user role
                };
                console.log('[AUDIT]', entry);
                // In production: send to backend API
                return entry;
            }
        };

        // Modal/Drawer Framework
        const modalBackdrop = document.getElementById('modalBackdrop');
        const modalContainer = document.getElementById('modalContainer');
        const modalClose = document.getElementById('modalClose');
        const modalCancel = document.getElementById('modalCancel');
        const modalTitle = document.getElementById('modalTitle');
        const modalSubtitle = document.getElementById('modalSubtitle');
        const modalBody = document.getElementById('modalBody');
        const modalFooter = document.getElementById('modalFooter');
        const modalConfirm = document.getElementById('modalConfirm');

        const MODAL = {
            // Open modal
            open: function (options = {}) {
                modalBackdrop.classList.add('active');
                modalContainer.classList.add('active');
                document.body.style.overflow = 'hidden';

                if (options.title) modalTitle.textContent = options.title;
                if (options.subtitle) modalSubtitle.textContent = options.subtitle;
                if (options.body) modalBody.innerHTML = options.body;
                if (options.confirmText) modalConfirm.textContent = options.confirmText;
                if (options.onConfirm) {
                    modalConfirm.onclick = () => {
                        options.onConfirm();
                        this.close();
                    };
                }
            },

            // Close modal
            close: function () {
                modalBackdrop.classList.remove('active');
                modalContainer.classList.remove('active');
                document.body.style.overflow = '';
            },

            // Quick helpers
            showInvite: function () {
                const currentUserRole = roleChip.textContent.includes('Owner') ? TEAM_ROLES.OWNER :
                    roleChip.textContent.includes('Manager') ? TEAM_ROLES.MANAGER : TEAM_ROLES.MEMBER;

                // Generate role options based on RBAC
                const roleOptions = Object.entries(ROLE_TEMPLATES)
                    .filter(([role]) => {
                        // Can only invite roles below your level
                        if (currentUserRole === TEAM_ROLES.OWNER) return true;
                        if (currentUserRole === TEAM_ROLES.MANAGER) return role !== TEAM_ROLES.OWNER;
                        return false;
                    })
                    .map(([role, template]) => `<option value="${role}">${template.label}</option>`)
                    .join('');

                this.open({
                    title: 'Invite Member',
                    subtitle: 'Send invitation to join team',
                    body: `
                        <div class="space-y-4">
                            <div>
                                <label class="text-sm font-semibold block mb-2">Email or Username</label>
                                <input type="text" id="inviteInput" placeholder="player@example.com or @username"
                                    class="w-full px-4 py-2 rounded-xl border border-line bg-white/5 outline-none focus:border-white/30 transition" />
                            </div>
                            <div>
                                <label class="text-sm font-semibold block mb-2">Invite as Role</label>
                                <select id="inviteRole" class="w-full px-4 py-2 rounded-xl border border-line bg-white/5 outline-none focus:border-white/30 transition">
                                    ${roleOptions}
                                </select>
                                <p class="text-xs text-muted mt-2" id="rolePermissionHint">Select a role to see permissions</p>
                            </div>
                            <div>
                                <label class="text-sm font-semibold block mb-2">Personal Message (optional)</label>
                                <textarea id="inviteMessage" rows="3" placeholder="Join our team for VCT qualifiers!"
                                    class="w-full px-4 py-2 rounded-xl border border-line bg-white/5 outline-none focus:border-white/30 transition resize-none"></textarea>
                            </div>
                        </div>
                    `,
                    confirmText: 'Send Invite',
                    onConfirm: () => {
                        const email = document.getElementById('inviteInput')?.value;
                        const role = document.getElementById('inviteRole')?.value;
                        const message = document.getElementById('inviteMessage')?.value;

                        if (!email) {
                            alert('Please enter an email or username');
                            return;
                        }

                        if (SECURITY.canInvite()) {
                            SECURITY.recordInvite();
                            SECURITY.logAudit('invite_sent', { email, role, message });
                            console.log('Invite sent to:', email, 'as', role);
                            alert(`Invite sent to ${email} as ${ROLE_TEMPLATES[role]?.label}!`);
                        } else {
                            alert('Invite rate limit exceeded (10/hour). Please try again later.');
                        }
                    }
                });

                // Update permission hint on role change
                setTimeout(() => {
                    const roleSelect = document.getElementById('inviteRole');
                    const hintEl = document.getElementById('rolePermissionHint');
                    roleSelect?.addEventListener('change', (e) => {
                        const selectedRole = e.target.value;
                        const template = ROLE_TEMPLATES[selectedRole];
                        if (template && hintEl) {
                            hintEl.textContent = `${template.permissions.length} permissions: ${template.label}`;
                        }
                    });
                }, 100);
            },

            showMemberProfile: function (memberData) {
                const readiness = ELIGIBILITY.checkPlayer(memberData);
                const missingFields = readiness.missing.length > 0
                    ? `<div class="rounded-xl border border-yellow-500/30 bg-yellow-500/10 p-3 mt-3">
                        <div class="text-sm font-semibold text-yellow-400">Missing Fields</div>
                        <div class="text-xs text-yellow-300/80 mt-1">${readiness.missing.join(', ')}</div>
                    </div>`
                    : '';

                this.open({
                    title: memberData.name || 'Member Profile',
                    subtitle: `${memberData.role || 'Member'} â€¢ ${readiness.readiness}% Ready`,
                    body: `
                        <div class="space-y-4">
                            <div class="grid grid-cols-2 gap-3">
                                <div>
                                    <div class="text-xs text-muted">In-Game Name</div>
                                    <div class="text-sm font-semibold mt-1">${memberData.ign || 'â€”'}</div>
                                </div>
                                <div>
                                    <div class="text-xs text-muted">Region</div>
                                    <div class="text-sm font-semibold mt-1">${memberData.region || 'â€”'}</div>
                                </div>
                                <div>
                                    <div class="text-xs text-muted">Rank</div>
                                    <div class="text-sm font-semibold mt-1">${memberData.rank || 'â€”'}</div>
                                </div>
                                <div>
                                    <div class="text-xs text-muted">Game ID</div>
                                    <div class="text-sm font-semibold mt-1">${memberData.gameId || 'â€”'}</div>
                                </div>
                            </div>
                            ${missingFields}
                            <div class="rounded-xl border border-line bg-white/5 p-3">
                                <div class="text-xs text-muted">Tournament Readiness</div>
                                <div class="mt-2 h-2 bg-white/10 rounded-full overflow-hidden">
                                    <div class="h-full bg-gradient-to-r from-purple-500 to-blue-500"
                                        style="width: ${readiness.readiness}%"></div>
                                </div>
                                <div class="text-xs text-muted mt-1">${readiness.readiness}% Complete</div>
                            </div>
                        </div>
                    `,
                    confirmText: 'Close',
                    onConfirm: () => { }
                });

                // Hide cancel button for profile view
                setTimeout(() => {
                    const cancelBtn = document.getElementById('modalCancel');
                    if (cancelBtn) cancelBtn.style.display = 'none';
                }, 50);
            },

            showRoleChange: function (memberName, currentRole) {
                const userRole = roleChip.textContent.includes('Owner') ? TEAM_ROLES.OWNER : TEAM_ROLES.MANAGER;

                const roleOptions = Object.entries(ROLE_TEMPLATES)
                    .filter(([role]) => {
                        // Can only assign roles you can grant
                        return SECURITY.canGrantRole(userRole, role);
                    })
                    .map(([role, template]) =>
                        `<option value="${role}" ${role === currentRole ? 'selected' : ''}>${template.label}</option>`)
                    .join('');

                this.open({
                    title: 'Change Role',
                    subtitle: `Update ${memberName}'s team role`,
                    body: `
                        <div class="space-y-4">
                            <div>
                                <label class="text-sm font-semibold block mb-2">New Role</label>
                                <select id="newRoleSelect" class="w-full px-4 py-2 rounded-xl border border-line bg-white/5 outline-none focus:border-white/30 transition">
                                    ${roleOptions}
                                </select>
                                <p class="text-xs text-muted mt-2" id="roleChangeHint">Role change will update permissions immediately</p>
                            </div>
                            <div class="rounded-xl border border-line bg-white/5 p-3">
                                <div class="text-xs font-semibold mb-2">Current Role</div>
                                <div class="text-sm">${ROLE_TEMPLATES[currentRole]?.label || currentRole}</div>
                            </div>
                        </div>
                    `,
                    confirmText: 'Update Role',
                    onConfirm: () => {
                        const newRole = document.getElementById('newRoleSelect')?.value;
                        if (newRole && newRole !== currentRole) {
                            SECURITY.logAudit('role_changed', { member: memberName, from: currentRole, to: newRole });
                            console.log(`Role changed: ${memberName} from ${currentRole} to ${newRole}`);
                            alert(`${memberName}'s role updated to ${ROLE_TEMPLATES[newRole]?.label}!`);
                        }
                    }
                });
            },

            showRemoveMember: function (memberName) {
                this.open({
                    title: 'Remove Member',
                    subtitle: `Remove ${memberName} from team`,
                    body: `
                        <div class="space-y-4">
                            <div class="rounded-xl border border-yellow-500/30 bg-yellow-500/10 p-4">
                                <div class="flex items-start gap-3">
                                    <i data-lucide="alert-triangle" class="w-5 h-5 text-yellow-400 flex-shrink-0 mt-0.5"></i>
                                    <div>
                                        <div class="text-sm font-semibold text-yellow-400">Warning</div>
                                        <div class="text-xs text-yellow-300/80 mt-1">
                                            This will remove ${memberName} from the team roster. They will lose access to team resources and communications.
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div>
                                <label class="text-sm font-semibold block mb-2">Reason (optional)</label>
                                <textarea id="removeReason" rows="2" placeholder="Inactive, voluntary leave, etc."
                                    class="w-full px-4 py-2 rounded-xl border border-line bg-white/5 outline-none focus:border-white/30 transition resize-none"></textarea>
                            </div>
                        </div>
                    `,
                    confirmText: 'Remove Member',
                    onConfirm: () => {
                        const reason = document.getElementById('removeReason')?.value || 'No reason provided';
                        SECURITY.logAudit('member_removed', { member: memberName, reason });
                        console.log(`Member removed: ${memberName}. Reason: ${reason}`);
                        alert(`${memberName} has been removed from the team.`);
                    }
                });

                // Make confirm button red
                setTimeout(() => {
                    const confirmBtn = document.getElementById('modalConfirm');
                    if (confirmBtn) {
                        confirmBtn.className = 'px-4 py-2 rounded-xl border border-red-500/30 bg-gradient-to-r from-red-500/80 to-red-600/80 hover:opacity-90 transition text-sm font-semibold';
                    }
                }, 50);
            }
        };

        // Close modal handlers
        modalClose?.addEventListener('click', () => MODAL.close());
        modalCancel?.addEventListener('click', () => MODAL.close());
        modalBackdrop?.addEventListener('click', () => MODAL.close());

        // Escape key to close
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                MODAL.close();
                closeSidebar();
                closeDemo();
            }
        });

        // =========================
        // RBAC SCHEMA & ROLE TEMPLATES
        // =========================
        const TEAM_ROLES = {
            OWNER: 'OWNER', MANAGER: 'MANAGER', COACH: 'COACH', ANALYST: 'ANALYST',
            PLAYER: 'PLAYER', SUB: 'SUB', STAFF: 'STAFF', MEMBER: 'MEMBER'
        };

        const PERMISSIONS = {
            ROSTER_INVITE: 'roster.invite', ROSTER_REMOVE: 'roster.remove',
            ROSTER_ROLE_CHANGE: 'roster.role_change', ROSTER_BENCH: 'roster.bench', ROSTER_VIEW: 'roster.view',
            COMPETITION_REGISTER: 'competition.register', COMPETITION_CHECKIN: 'competition.checkin',
            COMPETITION_REPORT: 'competition.report', COMPETITION_DISPUTE: 'competition.dispute', COMPETITION_VIEW: 'competition.view',
            CONTENT_POST: 'content.post', CONTENT_PIN: 'content.pin', CONTENT_MODERATE: 'content.moderate',
            CONTENT_UPLOAD: 'content.upload', CONTENT_VIEW: 'content.view',
            PROFILE_EDIT_IDENTITY: 'profile.edit_identity', PROFILE_EDIT_MODULES: 'profile.edit_modules',
            PROFILE_EDIT_BRANDING: 'profile.edit_branding', PROFILE_VIEW: 'profile.view',
            SETTINGS_PRIVACY: 'settings.privacy', SETTINGS_NOTIFICATIONS: 'settings.notifications',
            SETTINGS_INTEGRATIONS: 'settings.integrations', SETTINGS_DANGER: 'settings.danger',
            AUDIT_VIEW: 'audit.view', AUDIT_EXPORT: 'audit.export'
        };

        const ROLE_TEMPLATES = {
            [TEAM_ROLES.OWNER]: { label: 'ðŸ‘‘ Owner', permissions: Object.values(PERMISSIONS) },
            [TEAM_ROLES.MANAGER]: {
                label: 'ðŸ’¼ Manager',
                permissions: [
                    PERMISSIONS.ROSTER_INVITE, PERMISSIONS.ROSTER_REMOVE, PERMISSIONS.ROSTER_ROLE_CHANGE,
                    PERMISSIONS.ROSTER_BENCH, PERMISSIONS.ROSTER_VIEW, PERMISSIONS.COMPETITION_REGISTER,
                    PERMISSIONS.COMPETITION_CHECKIN, PERMISSIONS.COMPETITION_REPORT, PERMISSIONS.COMPETITION_DISPUTE,
                    PERMISSIONS.COMPETITION_VIEW, PERMISSIONS.CONTENT_POST, PERMISSIONS.CONTENT_PIN,
                    PERMISSIONS.CONTENT_MODERATE, PERMISSIONS.CONTENT_UPLOAD, PERMISSIONS.CONTENT_VIEW,
                    PERMISSIONS.PROFILE_EDIT_IDENTITY, PERMISSIONS.PROFILE_EDIT_MODULES, PERMISSIONS.PROFILE_VIEW,
                    PERMISSIONS.SETTINGS_PRIVACY, PERMISSIONS.SETTINGS_NOTIFICATIONS, PERMISSIONS.AUDIT_VIEW
                ]
            },
            [TEAM_ROLES.COACH]: {
                label: 'ðŸ‘” Coach',
                permissions: [PERMISSIONS.ROSTER_VIEW, PERMISSIONS.COMPETITION_CHECKIN, PERMISSIONS.COMPETITION_VIEW,
                PERMISSIONS.CONTENT_POST, PERMISSIONS.CONTENT_UPLOAD, PERMISSIONS.CONTENT_VIEW, PERMISSIONS.PROFILE_VIEW]
            },
            [TEAM_ROLES.ANALYST]: {
                label: 'ðŸ“Š Analyst',
                permissions: [PERMISSIONS.ROSTER_VIEW, PERMISSIONS.COMPETITION_VIEW, PERMISSIONS.CONTENT_UPLOAD,
                PERMISSIONS.CONTENT_VIEW, PERMISSIONS.PROFILE_VIEW]
            },
            [TEAM_ROLES.PLAYER]: {
                label: 'ðŸŽ® Player',
                permissions: [PERMISSIONS.ROSTER_VIEW, PERMISSIONS.COMPETITION_CHECKIN, PERMISSIONS.COMPETITION_VIEW,
                PERMISSIONS.CONTENT_VIEW, PERMISSIONS.PROFILE_VIEW]
            },
            [TEAM_ROLES.SUB]: {
                label: 'ðŸ”„ Substitute',
                permissions: [PERMISSIONS.ROSTER_VIEW, PERMISSIONS.COMPETITION_VIEW, PERMISSIONS.CONTENT_VIEW, PERMISSIONS.PROFILE_VIEW]
            },
            [TEAM_ROLES.STAFF]: {
                label: 'ðŸ‘¥ Staff',
                permissions: [PERMISSIONS.ROSTER_VIEW, PERMISSIONS.COMPETITION_VIEW, PERMISSIONS.CONTENT_POST,
                PERMISSIONS.CONTENT_VIEW, PERMISSIONS.PROFILE_VIEW]
            },
            [TEAM_ROLES.MEMBER]: {
                label: 'ðŸ‘¤ Member',
                permissions: [PERMISSIONS.ROSTER_VIEW, PERMISSIONS.COMPETITION_VIEW, PERMISSIONS.CONTENT_VIEW, PERMISSIONS.PROFILE_VIEW]
            }
        };

        const RBAC = {
            hasPermission: (role, permission) => {
                const template = ROLE_TEMPLATES[role];
                return template ? template.permissions.includes(permission) : false;
            },
            canPerform: (userRole, action) => RBAC.hasPermission(userRole, action),
            getRoleInfo: (role) => ROLE_TEMPLATES[role] || null
        };

        // =========================
        // ROSTER LOCK & ELIGIBILITY ENGINE
        // =========================
        const ROSTER_LOCK = {
            // Lock types
            LOCK_TYPES: {
                NONE: 'NONE',              // No lock
                REGISTRATION: 'REGISTRATION', // Locked during tournament registration
                MATCH: 'MATCH',            // Locked during active match
                PERMANENT: 'PERMANENT'      // Permanently locked (e.g., historical data)
            },

            // Current lock state (demo)
            currentLock: {
                type: 'NONE',
                tournamentId: null,
                matchId: null,
                lockedAt: null,
                lockedBy: null
            },

            // Check if roster is locked
            isLocked: function () {
                return this.currentLock.type !== this.LOCK_TYPES.NONE;
            },

            // Lock roster for tournament
            lockForTournament: function (tournamentId, userId) {
                if (this.isLocked()) {
                    console.warn('Roster already locked');
                    return false;
                }
                this.currentLock = {
                    type: this.LOCK_TYPES.REGISTRATION,
                    tournamentId: tournamentId,
                    matchId: null,
                    lockedAt: new Date().toISOString(),
                    lockedBy: userId
                };
                SECURITY.logAudit('roster_locked', { tournamentId, type: 'REGISTRATION' });
                return true;
            },

            // Unlock roster
            unlock: function (userId) {
                if (!this.isLocked()) return false;
                const prevLock = { ...this.currentLock };
                this.currentLock = {
                    type: this.LOCK_TYPES.NONE,
                    tournamentId: null,
                    matchId: null,
                    lockedAt: null,
                    lockedBy: null
                };
                SECURITY.logAudit('roster_unlocked', { previousLock: prevLock });
                return true;
            },

            // Check if action is allowed
            canModify: function (action) {
                if (!this.isLocked()) return true;

                // During registration lock, some actions may be restricted
                if (this.currentLock.type === this.LOCK_TYPES.REGISTRATION) {
                    const allowedDuringReg = ['view', 'checkin'];
                    return allowedDuringReg.includes(action);
                }

                // During match lock, no modifications allowed
                if (this.currentLock.type === this.LOCK_TYPES.MATCH) {
                    return action === 'view';
                }

                return false;
            }
        };

        // Eligibility checker for tournament registration
        const ELIGIBILITY = {
            // Required fields for tournament registration
            REQUIRED_FIELDS: {
                player: ['ign', 'region', 'rank', 'gameId'],
                team: ['name', 'tag', 'region', 'logo']
            },

            // Check player eligibility
            checkPlayer: function (playerData) {
                const missing = [];
                this.REQUIRED_FIELDS.player.forEach(field => {
                    if (!playerData[field]) missing.push(field);
                });
                return {
                    eligible: missing.length === 0,
                    missing: missing,
                    readiness: missing.length === 0 ? 100 : Math.round((1 - missing.length / this.REQUIRED_FIELDS.player.length) * 100)
                };
            },

            // Check team eligibility
            checkTeam: function (teamData) {
                const missing = [];
                this.REQUIRED_FIELDS.team.forEach(field => {
                    if (!teamData[field]) missing.push(field);
                });
                return {
                    eligible: missing.length === 0,
                    missing: missing,
                    readiness: missing.length === 0 ? 100 : Math.round((1 - missing.length / this.REQUIRED_FIELDS.team.length) * 100)
                };
            },

            // Check full roster eligibility
            checkRoster: function (roster, minPlayers = 5) {
                const results = roster.map(player => this.checkPlayer(player));
                const eligible = results.filter(r => r.eligible).length;
                const totalReadiness = results.reduce((sum, r) => sum + r.readiness, 0) / results.length;

                return {
                    eligible: eligible >= minPlayers,
                    eligibleCount: eligible,
                    totalCount: roster.length,
                    minRequired: minPlayers,
                    readiness: Math.round(totalReadiness),
                    playerResults: results
                };
            }
        };

        // Game label chip (demo)
        function applyGame(game) {
            const map = {
                VALORANT: "ðŸŽ¯ VALORANT",
                CS2: "ðŸ”« CS2",
                DOTA2: "ðŸ›¡ï¸ Dota 2",
                MLBB: "ðŸ“± MLBB",
                PUBG_MOBILE: "ðŸŽ® PUBG Mobile",
                FREE_FIRE: "ðŸ”¥ Free Fire",
                COD_MOBILE: "ðŸ’£ COD Mobile",
                EA_FC_26: "âš½ EA FC 26",
                EFOOTBALL_2026: "âš½ eFootball 2026",
                R6_SIEGE: "ðŸ° R6 Siege",
                ROCKET_LEAGUE: "ðŸš— Rocket League"
            };
            gameChip.textContent = map[game] || "ðŸŽ¯ VALORANT";
        }

        // Color helpers
        function isHex(s) {
            return /^#([0-9a-fA-F]{6})$/.test((s || '').trim());
        }
        function setColors(primary, accent) {
            if (isHex(primary)) document.documentElement.style.setProperty('--team-primary', primary);
            if (isHex(accent)) document.documentElement.style.setProperty('--team-accent', accent);
        }

        // Sync color inputs
        function syncPrimary(val) {
            if (isHex(val)) {
                demoPrimary.value = val;
                demoPrimaryHex.value = val;
                setColors(val, demoAccent.value);
            }
        }
        function syncAccent(val) {
            if (isHex(val)) {
                demoAccent.value = val;
                demoAccentHex.value = val;
                setColors(demoPrimary.value, val);
            }
        }

        demoPrimary?.addEventListener('input', e => syncPrimary(e.target.value));
        demoAccent?.addEventListener('input', e => syncAccent(e.target.value));

        demoPrimaryHex?.addEventListener('input', e => {
            const v = e.target.value.trim();
            if (isHex(v)) syncPrimary(v);
        });
        demoAccentHex?.addEventListener('input', e => {
            const v = e.target.value.trim();
            if (isHex(v)) syncAccent(v);
        });

        demoResetColors?.addEventListener('click', () => {
            syncPrimary('#7c3aed');
            syncAccent('#22c55e');
        });

        demoRole?.addEventListener('change', (e) => applyRole(e.target.value));
        demoGame?.addEventListener('change', (e) => applyGame(e.target.value));

        // Initial route + initial demo values
        const initialRoute = (location.hash || '#command').replace('#', '');
        setActiveRoute(document.getElementById(initialRoute) ? initialRoute : 'command');

        applyRole(demoRole?.value || 'OWNER');
        applyGame(demoGame?.value || 'VALORANT');
        setColors(demoPrimary?.value || '#7c3aed', demoAccent?.value || '#22c55e');
    </script>

