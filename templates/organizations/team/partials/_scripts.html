    <script>
    /**
     * Team Detail Page — Client-Side Controller
     * Phase 3 Production Build
     *
     * Modules:
     *   1. Body Data-Attribute Injection (role, theme, game)
     *   2. Sticky Nav Glass Effect
     *   3. Scrollspy (IntersectionObserver)
     *   4. Match Filter Tabs
     *   5. Lazy Image Loading
     *   6. Scroll-In Animations
     *   7. Sticky Sidebar Positioning
     */
    document.addEventListener("DOMContentLoaded", () => {

      // ─── 1. BODY DATA-ATTRIBUTES ───────────────────────────
      // Inject role/theme/game from Django context via data-bootstrap
      const bootstrapEl = document.getElementById("dc-detail-bootstrap");
      if (bootstrapEl) {
        const { role, theme, game, customColors } = bootstrapEl.dataset;
        if (role)  document.body.setAttribute("data-role", role);
        if (theme) document.body.setAttribute("data-theme", theme);
        if (game)  document.body.setAttribute("data-game", game);
        if (customColors === "true") document.body.setAttribute("data-custom-colors", "true");
      }

      // ─── 2. STICKY NAV GLASS ──────────────────────────────
      const nav = document.getElementById("dc-subnav");
      if (nav) {
        let lastScroll = 0;
        window.addEventListener("scroll", () => {
          const scrollY = window.scrollY;
          if (scrollY > 400) {
            nav.classList.add("bg-[#000]/90", "backdrop-blur-xl", "shadow-2xl");
            nav.classList.remove("bg-[#000]/80", "backdrop-blur-md");
          } else {
            nav.classList.remove("bg-[#000]/90", "backdrop-blur-xl", "shadow-2xl");
            nav.classList.add("bg-[#000]/80", "backdrop-blur-md");
          }
          lastScroll = scrollY;
        }, { passive: true });
      }

      // ─── 3. SCROLLSPY ─────────────────────────────────────
      const sections = document.querySelectorAll("section[id]");
      const navLinks = document.querySelectorAll("#dc-subnav .nav-link");

      if (sections.length && navLinks.length) {
        const observerOptions = {
          root: null,
          rootMargin: "-20% 0px -60% 0px",
          threshold: 0
        };

        const scrollspyObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const sectionId = entry.target.getAttribute("id");
              navLinks.forEach(link => {
                const linkTarget = link.getAttribute("data-nav");
                const neon = link.querySelector(".nav-neon");
                const isOps = linkTarget === "operations";

                if (linkTarget === sectionId) {
                  link.classList.add(isOps ? "text-emerald-400" : "text-[var(--team-primary)]");
                  link.classList.remove("text-slate-500");
                  if (neon) { neon.style.opacity = "1"; }
                } else {
                  link.classList.remove("text-[var(--team-primary)]", "text-emerald-400");
                  link.classList.add("text-slate-500");
                  if (neon) { neon.style.opacity = "0"; }
                }
              });
            }
          });
        }, observerOptions);

        sections.forEach(section => scrollspyObserver.observe(section));

        // Smooth scroll on nav click
        navLinks.forEach(link => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            const targetId = link.getAttribute("href")?.replace("#", "");
            const target = targetId && document.getElementById(targetId);
            if (target) {
              const offset = nav ? nav.offsetHeight + 20 : 80;
              const top = target.getBoundingClientRect().top + window.scrollY - offset;
              window.scrollTo({ top, behavior: "smooth" });
            }
          });
        });
      }

      // ─── 4. MATCH FILTER TABS ─────────────────────────────
      const filterBtns = document.querySelectorAll(".match-filter-btn");
      filterBtns.forEach(btn => {
        btn.addEventListener("click", () => {
          filterBtns.forEach(b => {
            b.classList.remove("bg-white/10", "text-white");
            b.classList.add("text-slate-500", "hover:bg-white/5");
          });
          btn.classList.remove("text-slate-500", "hover:bg-white/5");
          btn.classList.add("bg-white/10", "text-white");
          // Future: filter match cards by btn.dataset.filter
        });
      });

      // ─── 5. LAZY IMAGE LOADING ────────────────────────────
      const lazyImages = document.querySelectorAll(".lazy-media");
      if (lazyImages.length) {
        const imageObserver = new IntersectionObserver((entries, observer) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              entry.target.classList.add("loaded");
              observer.unobserve(entry.target);
            }
          });
        }, { rootMargin: "100px" });

        lazyImages.forEach(img => {
          img.classList.remove("loaded");
          imageObserver.observe(img);
        });
      }

      // ─── 6. SCROLL-IN ANIMATIONS ─────────────────────────
      const animatedSections = document.querySelectorAll("section.transition-smooth");
      if (animatedSections.length) {
        const scrollAnimObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              entry.target.style.opacity = "0";
              entry.target.style.transform = "translateY(20px)";
              requestAnimationFrame(() => {
                entry.target.style.transition = "opacity 0.6s ease, transform 0.6s ease";
                entry.target.style.opacity = "1";
                entry.target.style.transform = "translateY(0)";
              });
              scrollAnimObserver.unobserve(entry.target);
            }
          });
        }, { threshold: 0.08 });

        animatedSections.forEach(el => scrollAnimObserver.observe(el));
      }

      // ─── 7. STICKY SIDEBAR ────────────────────────────────
      function adjustSidebar() {
        const mainCol = document.getElementById("dc-main-col");
        const sidebar = document.getElementById("dc-sidebar");
        if (!mainCol || !sidebar || window.innerWidth < 1024) {
          if (sidebar) {
            sidebar.style.position = "";
            sidebar.style.top = "";
            sidebar.style.alignSelf = "";
          }
          return;
        }
        const mainH = mainCol.offsetHeight;
        const sideH = sidebar.offsetHeight;
        if (sideH < mainH) {
          sidebar.style.position = "sticky";
          sidebar.style.top = "80px";
          sidebar.style.alignSelf = "start";
        } else {
          sidebar.style.position = "";
          sidebar.style.top = "";
          sidebar.style.alignSelf = "";
        }
      }
      adjustSidebar();
      window.addEventListener("resize", adjustSidebar, { passive: true });

    });

    // ═══════════════════════════════════════════════════════════
    // 8. INVITE ACCEPT / DECLINE
    // ═══════════════════════════════════════════════════════════
    {% if pending_actions.has_pending_invite and pending_actions.pending_invite_id %}
    function dcInviteAction(action) {
      const inviteId = {{ pending_actions.pending_invite_id }};
      const csrfToken = document.querySelector("[name=csrfmiddlewaretoken]")?.value
                     || document.cookie.match(/csrftoken=([^;]+)/)?.[1] || "";

      // Disable all invite buttons across both CTA and sidebar
      document.querySelectorAll("#dc-invite-actions button, #dc-sidebar-invite-actions button").forEach(b => {
        b.disabled = true;
        b.style.opacity = "0.5";
      });

      // Try the notifications API first (used by bell/dashboard), fallback to vNext API
      const urls = [
        `/notifications/api/team-invite/${inviteId}/${action}/`,
        `/api/vnext/teams/invites/membership/${inviteId}/${action}/`
      ];

      (async function tryInvite(urlIdx) {
        if (urlIdx >= urls.length) {
          showInviteMsg("error", "Something went wrong. Please reload and try again.");
          return;
        }
        try {
          const resp = await fetch(urls[urlIdx], {
            method: "POST",
            headers: {
              "X-CSRFToken": csrfToken,
              "Content-Type": "application/json",
              "X-Requested-With": "XMLHttpRequest"
            },
            credentials: "same-origin"
          });
          if (resp.ok || resp.status === 200 || resp.status === 204) {
            const isAccept = action === "accept";
            showInviteMsg(
              isAccept ? "success" : "info",
              isAccept ? "Welcome to the team! Reloading..." : "Invite declined."
            );
            if (isAccept) {
              setTimeout(() => window.location.reload(), 1200);
            } else {
              setTimeout(() => {
                // Hide invite UI elements
                const dd = document.getElementById("dc-invite-dropdown");
                const wrap = document.getElementById("dc-invite-cta-wrap");
                const sidebar = document.getElementById("dc-sidebar-invite");
                if (dd) dd.classList.add("hidden");
                if (wrap) wrap.style.display = "none";
                if (sidebar) sidebar.style.display = "none";
              }, 1500);
            }
          } else if (resp.status === 404 || resp.status === 405) {
            // This API endpoint doesn't exist, try next
            tryInvite(urlIdx + 1);
          } else {
            const data = await resp.json().catch(() => ({}));
            showInviteMsg("error", data.detail || data.error || `Failed (${resp.status})`);
          }
        } catch (err) {
          tryInvite(urlIdx + 1);
        }
      })(0);
    }

    function showInviteMsg(type, text) {
      const colors = { success: "text-emerald-400", error: "text-red-400", info: "text-slate-300" };
      // Update both CTA dropdown and sidebar messages
      ["dc-invite-msg", "dc-sidebar-invite-msg"].forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          el.className = `mt-2 text-center text-xs font-bold ${colors[type] || "text-white"}`;
          el.textContent = text;
        }
      });
    }
    {% endif %}

    // ═══════════════════════════════════════════════════════════
    // 9. PLAYER POPUP
    // ═══════════════════════════════════════════════════════════
    function dcShowPlayerPopup(cardEl) {
      const popup = document.getElementById("dc-player-popup");
      if (!popup) return;

      // Extract data from card
      const d = cardEl.dataset;
      document.getElementById("pp-avatar").src = d.avatar || "";
      document.getElementById("pp-avatar").alt = d.display || "";
      document.getElementById("pp-name").textContent = d.display || d.username || "";
      document.getElementById("pp-username").textContent = d.username || "";
      document.getElementById("pp-role-chip").textContent = d.role || "PLAYER";
      document.getElementById("pp-profile-link").href = d.profileUrl || "#";

      // Player role (game-specific)
      const prEl = document.getElementById("pp-player-role");
      if (d.playerRole) {
        prEl.textContent = d.playerRole;
        prEl.style.display = "";
      } else {
        prEl.style.display = "none";
      }

      // Captain chip
      const captainChip = document.getElementById("pp-captain-chip");
      if (d.captain === "true") {
        captainChip.classList.remove("hidden");
      } else {
        captainChip.classList.add("hidden");
      }

      // Show popup
      popup.classList.remove("hidden");
      document.body.style.overflow = "hidden";
    }

    function dcClosePlayerPopup() {
      const popup = document.getElementById("dc-player-popup");
      if (popup) {
        popup.classList.add("hidden");
        document.body.style.overflow = "";
      }
    }

    // Close popup on Escape key
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        dcClosePlayerPopup();
        // Also close invite dropdown
        const dd = document.getElementById("dc-invite-dropdown");
        if (dd) dd.classList.add("hidden");
        // Close apply modal
        dcCloseApplyModal();
        // Close pending dropdown
        const pd = document.getElementById("dc-pending-dropdown");
        if (pd) pd.classList.add("hidden");
      }
    });

    // Close invite dropdown when clicking outside
    document.addEventListener("click", (e) => {
      const wrap = document.getElementById("dc-invite-cta-wrap");
      const dd = document.getElementById("dc-invite-dropdown");
      if (wrap && dd && !wrap.contains(e.target)) {
        dd.classList.add("hidden");
      }
      // Close pending dropdown when clicking outside
      const pw = document.getElementById("dc-pending-cta-wrap");
      const pd = document.getElementById("dc-pending-dropdown");
      if (pw && pd && !pw.contains(e.target)) {
        pd.classList.add("hidden");
      }
    });

    // ═══════════════════════════════════════════════════════
    // APPLY / JOIN REQUEST SYSTEM
    // ═══════════════════════════════════════════════════════

    function dcOpenApplyModal() {
      const modal = document.getElementById("dc-apply-modal");
      if (!modal) return;
      modal.classList.remove("hidden");
      modal.classList.add("flex");
      document.body.style.overflow = "hidden";
      // Focus the textarea
      const ta = document.getElementById("dc-apply-message");
      if (ta) setTimeout(() => ta.focus(), 100);
    }

    function dcCloseApplyModal() {
      const modal = document.getElementById("dc-apply-modal");
      if (!modal) return;
      modal.classList.add("hidden");
      modal.classList.remove("flex");
      document.body.style.overflow = "";
    }

    // Close modal on backdrop click
    (function() {
      const modal = document.getElementById("dc-apply-modal");
      if (modal) {
        modal.addEventListener("click", (e) => {
          if (e.target === modal) dcCloseApplyModal();
        });
      }
    })();

    // Character counter for apply message
    (function() {
      const ta = document.getElementById("dc-apply-message");
      const counter = document.getElementById("dc-apply-charcount");
      if (ta && counter) {
        ta.addEventListener("input", () => {
          counter.textContent = ta.value.length;
        });
      }
    })();

    async function dcSubmitApplication() {
      const btn = document.getElementById("dc-apply-submit");
      const errEl = document.getElementById("dc-apply-error");
      const ta = document.getElementById("dc-apply-message");
      if (!btn) return;

      btn.disabled = true;
      btn.innerHTML = '<svg class="w-4 h-4 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke-width="2" stroke-dasharray="31.4 31.4" /></svg> Submitting...';
      if (errEl) { errEl.classList.add("hidden"); errEl.textContent = ""; }

      try {
        const resp = await fetch(`/api/vnext/teams/{{ team.slug }}/apply/`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": document.querySelector("[name=csrfmiddlewaretoken]")?.value || "{{ csrf_token }}",
          },
          body: JSON.stringify({ message: ta ? ta.value.trim() : "" }),
        });
        const data = await resp.json();
        if (resp.ok && data.success) {
          dcCloseApplyModal();
          // Replace APPLY buttons with PENDING state
          location.reload();
        } else {
          if (errEl) {
            errEl.textContent = data.error || "Something went wrong. Please try again.";
            errEl.classList.remove("hidden");
          }
          btn.disabled = false;
          btn.innerHTML = '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/></svg> Submit Application';
        }
      } catch (err) {
        if (errEl) {
          errEl.textContent = "Network error. Please check your connection.";
          errEl.classList.remove("hidden");
        }
        btn.disabled = false;
        btn.innerHTML = '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/></svg> Submit Application';
      }
    }

    async function dcWithdrawApplication() {
      const btn = document.getElementById("dc-withdraw-btn");
      const msgEl = document.getElementById("dc-withdraw-msg");
      if (!btn) return;

      btn.disabled = true;
      btn.textContent = "Withdrawing...";

      try {
        const resp = await fetch(`/api/vnext/teams/{{ team.slug }}/apply/withdraw/`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": document.querySelector("[name=csrfmiddlewaretoken]")?.value || "{{ csrf_token }}",
          },
        });
        const data = await resp.json();
        if (resp.ok && data.success) {
          if (msgEl) {
            msgEl.textContent = "Application withdrawn.";
            msgEl.classList.remove("hidden");
            msgEl.classList.add("text-emerald-400");
          }
          setTimeout(() => location.reload(), 800);
        } else {
          if (msgEl) {
            msgEl.textContent = data.error || "Could not withdraw application.";
            msgEl.classList.remove("hidden");
            msgEl.classList.add("text-red-400");
          }
          btn.disabled = false;
          btn.textContent = "Withdraw Application";
        }
      } catch (err) {
        if (msgEl) {
          msgEl.textContent = "Network error.";
          msgEl.classList.remove("hidden");
          msgEl.classList.add("text-red-400");
        }
        btn.disabled = false;
        btn.textContent = "Withdraw Application";
      }
    }

    // ═══════════════════════════════════════════════════════════
    // P4. SMART ROSTER EXPAND / COLLAPSE
    // ═══════════════════════════════════════════════════════════
    function dcToggleRosterExpand() {
      const grid = document.getElementById("dc-roster-grid");
      const toggle = document.getElementById("dc-roster-toggle");
      const icon = document.getElementById("dc-roster-toggle-icon");
      if (!grid) return;

      const expanded = grid.dataset.expanded === "true";
      if (expanded) {
        // Collapse: show 5 cards, hide rest
        grid.dataset.expanded = "false";
        grid.style.maxHeight = "";
        grid.style.overflow = "";
        const cards = grid.querySelectorAll(".dc-roster-card");
        cards.forEach((card, i) => {
          if (i >= 5) {
            card.style.display = "none";
          }
        });
        if (toggle) toggle.childNodes[toggle.childNodes.length - 1].textContent = " Expand";
      } else {
        // Expand: show all cards
        grid.dataset.expanded = "true";
        const cards = grid.querySelectorAll(".dc-roster-card");
        cards.forEach(card => {
          card.style.display = "";
        });
        if (toggle) toggle.childNodes[toggle.childNodes.length - 1].textContent = " Collapse";
      }
    }

    // Auto-collapse roster if more than 5 members
    document.addEventListener("DOMContentLoaded", () => {
      const grid = document.getElementById("dc-roster-grid");
      if (grid) {
        const cards = grid.querySelectorAll(".dc-roster-card");
        if (cards.length > 5) {
          cards.forEach((card, i) => {
            if (i >= 5) card.style.display = "none";
          });
          grid.dataset.expanded = "false";
        } else {
          // Hide expand button if 5 or fewer
          const toggle = document.getElementById("dc-roster-toggle");
          if (toggle) toggle.style.display = "none";
        }
      }
    });

    // ═══════════════════════════════════════════════════════════
    // P5. GAME PROFILES — Dynamic Terminology & Stats Labels
    // ═══════════════════════════════════════════════════════════
    const DC_GAME_PROFILES = {
      'valorant':       { category: 'FPS_TACTICAL', player: 'Agent',    match: 'Series',     stat1: 'Rating',     stat2: 'Record',    stat3: 'ACS',       stat4: 'HS%'        },
      'cs2':            { category: 'FPS_TACTICAL', player: 'Player',   match: 'Match',      stat1: 'Rating 2.0', stat2: 'Record',    stat3: 'ADR',       stat4: 'KAST'       },
      'dota2':          { category: 'MOBA',         player: 'Hero',     match: 'Match',      stat1: 'MMR',        stat2: 'Win Rate',  stat3: 'GPM',       stat4: 'XPM'        },
      'mlbb':           { category: 'MOBA_MOBILE',  player: 'Legend',   match: 'Match',      stat1: 'Win Rate',   stat2: 'MVP',       stat3: 'Gold/min',  stat4: 'KDA'        },
      'pubgm':          { category: 'BATTLE_ROYALE', player: 'Player',  match: 'Tournament', stat1: 'Avg Dmg',    stat2: 'Top 10%',   stat3: 'K/D',       stat4: 'Survival'   },
      'freefire':       { category: 'BATTLE_ROYALE', player: 'Player',  match: 'Tournament', stat1: 'Booyahs',    stat2: 'K/D',       stat3: 'HS%',       stat4: 'Avg Surv'   },
      'codm':           { category: 'HYBRID_MOBILE', player: 'Player',  match: 'Match',      stat1: 'K/D (MP)',   stat2: 'Win Rate',  stat3: 'Accuracy',  stat4: 'Obj Score'  },
      'ea-fc':          { category: 'SPORTS',       player: 'Player',   match: 'Match',      stat1: 'Goals',      stat2: 'Win%',      stat3: 'Assists',   stat4: 'Clean Sh.'  },
      'efootball':      { category: 'SPORTS',       player: 'Player',   match: 'Match',      stat1: 'Goals',      stat2: 'Win Rate',  stat3: 'Pass%',     stat4: 'Possession' },
      'r6siege':        { category: 'FPS_TACTICAL', player: 'Operator', match: 'Match',      stat1: 'K/D',        stat2: 'Win%',      stat3: 'HS%',       stat4: 'KOST'       },
      'rocketleague':   { category: 'VEHICLE_SPORTS', player: 'Player', match: 'Series',     stat1: 'Goals/Game', stat2: 'Saves',     stat3: 'Shots',     stat4: 'Assists'    },
    };

    // Apply game-specific labels on page load
    document.addEventListener("DOMContentLoaded", () => {
      const gameSlug = document.body.getAttribute("data-game");
      if (!gameSlug || !DC_GAME_PROFILES[gameSlug]) return;

      const profile = DC_GAME_PROFILES[gameSlug];

      // Update dynamic terminology
      document.querySelectorAll('[data-term="player"]').forEach(el => { el.textContent = profile.player; });
      document.querySelectorAll('[data-term="match"]').forEach(el => { el.textContent = profile.match; });

      // Update game-specific stat labels
      const labelMap = {
        'stat-1': 'Total Played',
        'stat-2': profile.stat1,
        'stat-3': 'ELO Rating',
        'stat-4': 'Peak ELO',
        'gs-1': 'Record',
        'gs-2': 'Tournaments',
        'gs-3': 'Titles Won',
        'gs-4': 'Percentile',
      };

      Object.entries(labelMap).forEach(([key, val]) => {
        document.querySelectorAll(`[data-label="${key}"]`).forEach(el => {
          el.textContent = val;
        });
      });

      // Set game category class on body for CSS-driven visibility
      document.body.setAttribute("data-game-category", profile.category);
    });
    </script>

    {# ── P11: Challenge Hub Countdown Timers ────────────────── #}
    <script>
    (function() {
      document.addEventListener("DOMContentLoaded", () => {
        const countdowns = document.querySelectorAll("[data-countdown]");
        if (!countdowns.length) return;

        function formatTime(totalSeconds) {
          if (totalSeconds <= 0) return "EXPIRED";
          const h = Math.floor(totalSeconds / 3600);
          const m = Math.floor((totalSeconds % 3600) / 60);
          const s = Math.floor(totalSeconds % 60);
          return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        }

        countdowns.forEach(el => {
          let remaining = parseFloat(el.dataset.countdown);
          if (isNaN(remaining)) return;

          el.textContent = formatTime(remaining);

          const interval = setInterval(() => {
            remaining -= 1;
            el.textContent = formatTime(remaining);
            if (remaining <= 0) {
              clearInterval(interval);
              el.classList.remove("text-red-400");
              el.classList.add("text-slate-500");
            }
          }, 1000);
        });
      });
    })();
    </script>
