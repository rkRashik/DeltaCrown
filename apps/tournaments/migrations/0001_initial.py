# Generated by Django 5.2.8 on 2025-11-16 19:00

import django.contrib.postgres.fields
import django.contrib.postgres.indexes
import django.core.validators
import django.db.models.deletion
import uuid
from decimal import Decimal
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Bracket',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, help_text='Timestamp when this record was created')),
                ('format', models.CharField(choices=[('single-elimination', 'Single Elimination'), ('double-elimination', 'Double Elimination'), ('round-robin', 'Round Robin'), ('swiss', 'Swiss System'), ('group-stage', 'Group Stage')], default='single-elimination', help_text='Type of bracket structure', max_length=50, verbose_name='Bracket Format')),
                ('total_rounds', models.PositiveIntegerField(default=0, help_text='Total number of rounds in bracket', verbose_name='Total Rounds')),
                ('total_matches', models.PositiveIntegerField(default=0, help_text='Total number of matches in bracket', verbose_name='Total Matches')),
                ('bracket_structure', models.JSONField(blank=True, default=dict, help_text='JSONB tree structure metadata for bracket visualization', verbose_name='Bracket Structure')),
                ('seeding_method', models.CharField(choices=[('slot-order', 'Slot Order (First-Come-First-Served)'), ('random', 'Random Seeding'), ('ranked', 'Ranked Seeding'), ('manual', 'Manual Seeding')], default='slot-order', help_text='How participants are seeded into bracket', max_length=30, verbose_name='Seeding Method')),
                ('is_finalized', models.BooleanField(default=False, help_text='Whether bracket is locked and cannot be regenerated', verbose_name='Is Finalized')),
                ('generated_at', models.DateTimeField(auto_now_add=True, help_text='When bracket was initially generated', null=True, verbose_name='Generated At')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Last update timestamp', verbose_name='Updated At')),
            ],
            options={
                'verbose_name': 'Bracket',
                'verbose_name_plural': 'Brackets',
                'db_table': 'tournament_engine_bracket_bracket',
            },
        ),
        migrations.CreateModel(
            name='Game',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100, unique=True)),
                ('slug', models.SlugField(max_length=120, unique=True)),
                ('icon', models.ImageField(help_text='Game icon/logo image', upload_to='games/icons/')),
                ('default_team_size', models.PositiveIntegerField(choices=[(1, '1v1'), (2, '2v2'), (3, '3v3'), (4, '4v4'), (5, '5v5'), (0, 'Variable')], default=5, help_text='Default team size for this game')),
                ('profile_id_field', models.CharField(help_text="Field name in UserProfile (e.g., 'riot_id', 'steam_id')", max_length=50)),
                ('default_result_type', models.CharField(choices=[('map_score', 'Map Score (e.g., 13-11)'), ('best_of', 'Best of X'), ('point_based', 'Point Based')], default='map_score', help_text='How match results are recorded', max_length=20)),
                ('game_config', models.JSONField(blank=True, default=dict, help_text='Game configuration schema and settings (JSONB)')),
                ('is_active', models.BooleanField(db_index=True, default=True, help_text='Whether this game is actively supported')),
                ('description', models.TextField(blank=True, help_text='Game description and notes')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'verbose_name': 'Game',
                'verbose_name_plural': 'Games',
                'ordering': ['name'],
                'indexes': [models.Index(fields=['slug'], name='tournaments_slug_d1de23_idx'), models.Index(fields=['is_active', 'name'], name='tournaments_is_acti_b1f275_idx')],
            },
        ),
        migrations.CreateModel(
            name='Registration',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_deleted', models.BooleanField(db_index=True, default=False, help_text='Flag indicating if this record has been soft-deleted')),
                ('deleted_at', models.DateTimeField(blank=True, help_text='Timestamp when this record was deleted', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True, help_text='Timestamp when this record was created')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Timestamp when this record was last updated')),
                ('team_id', models.IntegerField(blank=True, db_index=True, help_text='Team ID reference (for team tournaments, IntegerField to avoid circular dependency)', null=True)),
                ('registration_data', models.JSONField(blank=True, default=dict, help_text='JSON storage for participant data (game IDs, contact info, custom fields)')),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('payment_submitted', 'Payment Submitted'), ('confirmed', 'Confirmed'), ('rejected', 'Rejected'), ('cancelled', 'Cancelled'), ('no_show', 'No Show')], db_index=True, default='pending', help_text='Current registration status', max_length=20)),
                ('registered_at', models.DateTimeField(auto_now_add=True, help_text='When registration was submitted', null=True)),
                ('checked_in', models.BooleanField(default=False, help_text='Whether participant has checked in on tournament day')),
                ('checked_in_at', models.DateTimeField(blank=True, help_text='When participant checked in', null=True)),
                ('slot_number', models.IntegerField(blank=True, help_text='Bracket slot number (1-based index for bracket position)', null=True)),
                ('seed', models.IntegerField(blank=True, help_text='Seeding number for bracket generation (lower = higher seed)', null=True)),
                ('checked_in_by', models.ForeignKey(blank=True, help_text='User who performed the check-in (owner, captain, or organizer)', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='checked_in_registrations', to=settings.AUTH_USER_MODEL)),
                ('deleted_by', models.ForeignKey(blank=True, help_text='User who deleted this record', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='%(class)s_deletions', to=settings.AUTH_USER_MODEL)),
                ('user', models.ForeignKey(blank=True, help_text='User who registered (for solo tournaments or team captain)', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='tournament_registrations', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Registration',
                'verbose_name_plural': 'Registrations',
                'db_table': 'tournaments_registration',
            },
        ),
        migrations.CreateModel(
            name='PaymentVerification',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('method', models.CharField(choices=[('bkash', 'bKash'), ('nagad', 'Nagad'), ('rocket', 'Rocket'), ('bank', 'Bank Transfer'), ('other', 'Other')], default='bkash', max_length=16)),
                ('payer_account_number', models.CharField(blank=True, help_text='Your bKash/Nagad/Rocket account number (payer)', max_length=32)),
                ('transaction_id', models.CharField(blank=True, help_text='Transaction ID from bKash/Nagad/Rocket', max_length=64)),
                ('reference_number', models.CharField(blank=True, help_text='Internal reference number for payment tracking', max_length=64, null=True)),
                ('amount_bdt', models.PositiveIntegerField(blank=True, null=True)),
                ('note', models.CharField(blank=True, max_length=255)),
                ('proof_image', models.ImageField(blank=True, null=True, upload_to='payments/proofs/')),
                ('notes', models.JSONField(blank=True, default=dict)),
                ('idempotency_key', models.CharField(blank=True, max_length=255, null=True, unique=True)),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('verified', 'Verified'), ('rejected', 'Rejected'), ('refunded', 'Refunded')], default='pending', max_length=16)),
                ('verified_at', models.DateTimeField(blank=True, null=True)),
                ('rejected_at', models.DateTimeField(blank=True, null=True)),
                ('refunded_at', models.DateTimeField(blank=True, null=True)),
                ('reject_reason', models.TextField(blank=True)),
                ('last_action_reason', models.CharField(blank=True, max_length=200)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('refunded_by', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='payments_refunded', to=settings.AUTH_USER_MODEL)),
                ('rejected_by', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='payments_rejected', to=settings.AUTH_USER_MODEL)),
                ('verified_by', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='payments_verified', to=settings.AUTH_USER_MODEL)),
                ('registration', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='payment_verification', to='tournaments.registration')),
            ],
            options={
                'verbose_name': 'Payment Verification',
                'verbose_name_plural': 'Payment Verifications',
                'db_table': 'tournaments_paymentverification',
            },
        ),
        migrations.CreateModel(
            name='Tournament',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_deleted', models.BooleanField(db_index=True, default=False, help_text='Flag indicating if this record has been soft-deleted')),
                ('deleted_at', models.DateTimeField(blank=True, help_text='Timestamp when this record was deleted', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True, help_text='Timestamp when this record was created')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Timestamp when this record was last updated')),
                ('name', models.CharField(help_text='Tournament name', max_length=200)),
                ('slug', models.SlugField(max_length=250, unique=True)),
                ('description', models.TextField(help_text='Tournament description and overview')),
                ('is_official', models.BooleanField(db_index=True, default=False, help_text='Whether this is an official DeltaCrown tournament')),
                ('format', models.CharField(choices=[('single_elimination', 'Single Elimination'), ('double_elimination', 'Double Elimination'), ('round_robin', 'Round Robin'), ('swiss', 'Swiss'), ('group_playoff', 'Group Stage + Playoff')], default='single_elimination', help_text='Bracket format for the tournament', max_length=50)),
                ('participation_type', models.CharField(choices=[('team', 'Team'), ('solo', 'Solo/Individual')], default='team', help_text='Whether teams or individuals participate', max_length=20)),
                ('max_participants', models.PositiveIntegerField(help_text='Maximum number of participants/teams', validators=[django.core.validators.MinValueValidator(2), django.core.validators.MaxValueValidator(256)])),
                ('min_participants', models.PositiveIntegerField(default=2, help_text='Minimum participants needed to start', validators=[django.core.validators.MinValueValidator(2)])),
                ('registration_start', models.DateTimeField(help_text='When registration opens')),
                ('registration_end', models.DateTimeField(help_text='When registration closes')),
                ('tournament_start', models.DateTimeField(help_text='When tournament begins')),
                ('tournament_end', models.DateTimeField(blank=True, help_text='When tournament ends (set automatically)', null=True)),
                ('prize_pool', models.DecimalField(decimal_places=2, default=Decimal('0.00'), help_text='Total prize pool amount', max_digits=10, validators=[django.core.validators.MinValueValidator(Decimal('0.00'))])),
                ('prize_currency', models.CharField(default='BDT', help_text='Currency for prize pool (BDT, USD, etc.)', max_length=10)),
                ('prize_deltacoin', models.PositiveIntegerField(default=0, help_text='Prize pool in DeltaCoins')),
                ('prize_distribution', models.JSONField(blank=True, default=dict, help_text='Prize distribution by placement (JSONB): {"1": "50%", "2": "30%", "3": "20%"}')),
                ('has_entry_fee', models.BooleanField(default=False, help_text='Whether tournament has an entry fee')),
                ('entry_fee_amount', models.DecimalField(decimal_places=2, default=Decimal('0.00'), help_text='Entry fee amount', max_digits=10, validators=[django.core.validators.MinValueValidator(Decimal('0.00'))])),
                ('entry_fee_currency', models.CharField(default='BDT', help_text='Currency for entry fee', max_length=10)),
                ('entry_fee_deltacoin', models.PositiveIntegerField(default=0, help_text='Entry fee in DeltaCoins')),
                ('payment_methods', django.contrib.postgres.fields.ArrayField(base_field=models.CharField(choices=[('deltacoin', 'DeltaCoin'), ('bkash', 'bKash'), ('nagad', 'Nagad'), ('rocket', 'Rocket'), ('bank_transfer', 'Bank Transfer')], max_length=20), blank=True, default=list, help_text='Accepted payment methods', size=None)),
                ('enable_fee_waiver', models.BooleanField(default=False, help_text='Enable automatic fee waiver for top teams')),
                ('fee_waiver_top_n_teams', models.PositiveIntegerField(default=0, help_text='Number of top teams eligible for fee waiver')),
                ('banner_image', models.ImageField(blank=True, help_text='Tournament banner image', null=True, upload_to='tournaments/banners/')),
                ('thumbnail_image', models.ImageField(blank=True, help_text='Tournament thumbnail for listings', null=True, upload_to='tournaments/thumbnails/')),
                ('rules_pdf', models.FileField(blank=True, help_text='Tournament rules PDF file', null=True, upload_to='tournaments/rules/')),
                ('promo_video_url', models.URLField(blank=True, help_text='YouTube/Vimeo promo video URL')),
                ('stream_youtube_url', models.URLField(blank=True, help_text='Official YouTube stream URL')),
                ('stream_twitch_url', models.URLField(blank=True, help_text='Official Twitch stream URL')),
                ('enable_check_in', models.BooleanField(default=True, help_text='Require participants to check in before matches')),
                ('check_in_minutes_before', models.PositiveIntegerField(default=15, help_text='Check-in window duration in minutes')),
                ('check_in_closes_minutes_before', models.PositiveIntegerField(default=10, help_text='Check-in closes this many minutes before tournament start')),
                ('enable_dynamic_seeding', models.BooleanField(default=False, help_text='Use team rankings for seeding instead of registration order')),
                ('enable_live_updates', models.BooleanField(default=True, help_text='Enable WebSocket live updates for spectators')),
                ('enable_certificates', models.BooleanField(default=True, help_text='Generate certificates for winners')),
                ('enable_challenges', models.BooleanField(default=False, help_text='Enable bonus challenges during tournament')),
                ('enable_fan_voting', models.BooleanField(default=False, help_text='Enable spectator voting/predictions')),
                ('rules_text', models.TextField(blank=True, help_text='Tournament rules in text format')),
                ('status', models.CharField(choices=[('draft', 'Draft'), ('pending_approval', 'Pending Approval'), ('published', 'Published'), ('registration_open', 'Registration Open'), ('registration_closed', 'Registration Closed'), ('live', 'Live'), ('completed', 'Completed'), ('cancelled', 'Cancelled'), ('archived', 'Archived')], db_index=True, default='draft', help_text='Current tournament status', max_length=30)),
                ('published_at', models.DateTimeField(blank=True, help_text='When tournament was published', null=True)),
                ('total_registrations', models.PositiveIntegerField(default=0, help_text='Total number of registrations')),
                ('total_matches', models.PositiveIntegerField(default=0, help_text='Total number of matches')),
                ('completed_matches', models.PositiveIntegerField(default=0, help_text='Number of completed matches')),
                ('meta_description', models.TextField(blank=True, help_text='Meta description for SEO')),
                ('meta_keywords', django.contrib.postgres.fields.ArrayField(base_field=models.CharField(max_length=50), blank=True, default=list, help_text='SEO keywords', size=None)),
                ('config', models.JSONField(blank=True, default=dict, help_text='Advanced tournament configuration and feature flags (JSONB)')),
                ('deleted_by', models.ForeignKey(blank=True, help_text='User who deleted this record', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='%(class)s_deletions', to=settings.AUTH_USER_MODEL)),
                ('game', models.ForeignKey(help_text='Game being played in this tournament', on_delete=django.db.models.deletion.PROTECT, related_name='tournaments', to='tournaments.game')),
                ('organizer', models.ForeignKey(help_text='User who created this tournament', on_delete=django.db.models.deletion.PROTECT, related_name='organized_tournaments', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Tournament',
                'verbose_name_plural': 'Tournaments',
                'ordering': ['-tournament_start'],
            },
        ),
        migrations.AddField(
            model_name='registration',
            name='tournament',
            field=models.ForeignKey(help_text='Tournament being registered for', on_delete=django.db.models.deletion.CASCADE, related_name='registrations', to='tournaments.tournament'),
        ),
        migrations.CreateModel(
            name='PrizeTransaction',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, help_text='Timestamp when this record was created')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Timestamp when this record was last updated')),
                ('placement', models.CharField(choices=[('1st', '1st Place'), ('2nd', '2nd Place'), ('3rd', '3rd Place'), ('participation', 'Participation Reward')], help_text='Placement earned by participant', max_length=20)),
                ('amount', models.DecimalField(decimal_places=2, help_text='Prize amount in Delta Coins', max_digits=10)),
                ('coin_transaction_id', models.IntegerField(blank=True, db_index=True, help_text='ID of DeltaCrownTransaction in apps.economy (reference only, not FK)', null=True)),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('completed', 'Completed'), ('failed', 'Failed'), ('refunded', 'Refunded')], default='pending', help_text='Current status of this prize transaction', max_length=20)),
                ('notes', models.TextField(blank=True, help_text='Optional notes for manual adjustments or reconciliation')),
                ('processed_by', models.ForeignKey(blank=True, help_text='User who triggered the payout', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='processed_prize_transactions', to=settings.AUTH_USER_MODEL)),
                ('participant', models.ForeignKey(help_text='Registration receiving this prize', on_delete=django.db.models.deletion.PROTECT, related_name='prize_transactions', to='tournaments.registration')),
                ('tournament', models.ForeignKey(help_text='Tournament awarding this prize', on_delete=django.db.models.deletion.CASCADE, related_name='prize_transactions', to='tournaments.tournament')),
            ],
            options={
                'verbose_name': 'Prize Transaction',
                'verbose_name_plural': 'Prize Transactions',
                'db_table': 'tournament_engine_prize_prizetransaction',
                'ordering': ['-created_at', '-id'],
            },
        ),
        migrations.CreateModel(
            name='Match',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_deleted', models.BooleanField(db_index=True, default=False, help_text='Flag indicating if this record has been soft-deleted')),
                ('deleted_at', models.DateTimeField(blank=True, help_text='Timestamp when this record was deleted', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True, help_text='Timestamp when this record was created')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Timestamp when this record was last updated')),
                ('round_number', models.PositiveIntegerField(help_text='Round number in bracket (1 = first round)', validators=[django.core.validators.MinValueValidator(1)], verbose_name='Round Number')),
                ('match_number', models.PositiveIntegerField(help_text='Match number within round', validators=[django.core.validators.MinValueValidator(1)], verbose_name='Match Number')),
                ('participant1_id', models.PositiveIntegerField(blank=True, help_text='Team ID or User ID for participant 1', null=True, verbose_name='Participant 1 ID')),
                ('participant1_name', models.CharField(blank=True, help_text='Denormalized name for display', max_length=100, verbose_name='Participant 1 Name')),
                ('participant2_id', models.PositiveIntegerField(blank=True, help_text='Team ID or User ID for participant 2', null=True, verbose_name='Participant 2 ID')),
                ('participant2_name', models.CharField(blank=True, help_text='Denormalized name for display', max_length=100, verbose_name='Participant 2 Name')),
                ('state', models.CharField(choices=[('scheduled', 'Scheduled'), ('check_in', 'Check-in Open'), ('ready', 'Ready to Start'), ('live', 'Live/In Progress'), ('pending_result', 'Pending Result'), ('completed', 'Completed'), ('disputed', 'Disputed'), ('forfeit', 'Forfeit'), ('cancelled', 'Cancelled')], db_index=True, default='scheduled', help_text='Current state in match lifecycle', max_length=20, verbose_name='State')),
                ('participant1_score', models.PositiveIntegerField(default=0, help_text='Score for participant 1', validators=[django.core.validators.MinValueValidator(0)], verbose_name='Participant 1 Score')),
                ('participant2_score', models.PositiveIntegerField(default=0, help_text='Score for participant 2', validators=[django.core.validators.MinValueValidator(0)], verbose_name='Participant 2 Score')),
                ('winner_id', models.PositiveIntegerField(blank=True, db_index=True, help_text='Team ID or User ID of winner (set when match completed)', null=True, verbose_name='Winner ID')),
                ('loser_id', models.PositiveIntegerField(blank=True, help_text='Team ID or User ID of loser (set when match completed)', null=True, verbose_name='Loser ID')),
                ('lobby_info', models.JSONField(blank=True, default=dict, help_text='Game lobby details (map, server, lobby code, password, etc.). Example: {"game_mode": "Competitive", "map": "Haven", "lobby_code": "ABC123"}', verbose_name='Lobby Info')),
                ('stream_url', models.URLField(blank=True, help_text='Twitch/YouTube stream URL for spectators', verbose_name='Stream URL')),
                ('scheduled_time', models.DateTimeField(blank=True, db_index=True, help_text='When match is scheduled to start', null=True, verbose_name='Scheduled Time')),
                ('check_in_deadline', models.DateTimeField(blank=True, help_text='Deadline for participants to check in', null=True, verbose_name='Check-in Deadline')),
                ('participant1_checked_in', models.BooleanField(default=False, help_text='Whether participant 1 has checked in', verbose_name='Participant 1 Checked In')),
                ('participant2_checked_in', models.BooleanField(default=False, help_text='Whether participant 2 has checked in', verbose_name='Participant 2 Checked In')),
                ('started_at', models.DateTimeField(blank=True, help_text='When match actually started (state → LIVE)', null=True, verbose_name='Started At')),
                ('completed_at', models.DateTimeField(blank=True, help_text='When match was completed (state → COMPLETED)', null=True, verbose_name='Completed At')),
                ('bracket', models.ForeignKey(blank=True, help_text='Bracket this match belongs to (null for group stage)', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='matches', to='tournaments.bracket', verbose_name='Bracket')),
                ('deleted_by', models.ForeignKey(blank=True, help_text='User who deleted this record', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='%(class)s_deletions', to=settings.AUTH_USER_MODEL)),
                ('tournament', models.ForeignKey(help_text='Tournament this match belongs to', on_delete=django.db.models.deletion.CASCADE, related_name='matches', to='tournaments.tournament', verbose_name='Tournament')),
            ],
            options={
                'verbose_name': 'Match',
                'verbose_name_plural': 'Matches',
                'db_table': 'tournament_engine_match_match',
                'ordering': ['tournament', 'round_number', 'match_number'],
            },
        ),
        migrations.CreateModel(
            name='CustomField',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('field_name', models.CharField(help_text='Display name of the field', max_length=100)),
                ('field_key', models.SlugField(help_text='Unique key for form field name', max_length=120)),
                ('field_type', models.CharField(choices=[('text', 'Text'), ('number', 'Number'), ('media', 'Media Upload'), ('toggle', 'Toggle (Yes/No)'), ('date', 'Date'), ('url', 'URL'), ('dropdown', 'Dropdown')], default='text', help_text='Type of field (text, number, etc.)', max_length=20)),
                ('field_config', models.JSONField(blank=True, default=dict, help_text='Field configuration (min_length, max_length, options, etc.)')),
                ('field_value', models.JSONField(blank=True, default=dict, help_text='Actual field value storage')),
                ('order', models.PositiveIntegerField(default=0, help_text='Display order (lower numbers first)')),
                ('is_required', models.BooleanField(default=False, help_text='Whether this field is required')),
                ('help_text', models.CharField(blank=True, help_text='Help text shown to users', max_length=200)),
                ('tournament', models.ForeignKey(help_text='Tournament this field belongs to', on_delete=django.db.models.deletion.CASCADE, related_name='custom_fields', to='tournaments.tournament')),
            ],
            options={
                'verbose_name': 'Custom Field',
                'verbose_name_plural': 'Custom Fields',
                'ordering': ['order', 'field_name'],
            },
        ),
        migrations.CreateModel(
            name='Certificate',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, help_text='Timestamp when this record was created')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Timestamp when this record was last updated')),
                ('certificate_type', models.CharField(choices=[('winner', 'Winner Certificate'), ('runner_up', 'Runner-up Certificate'), ('third_place', 'Third Place Certificate'), ('participant', 'Participation Certificate')], help_text='Type of certificate (winner, runner-up, etc.)', max_length=20)),
                ('placement', models.CharField(blank=True, default='', help_text="Placement string (e.g., '1st', '2nd', '3rd') for display", max_length=20)),
                ('file_pdf', models.FileField(blank=True, help_text='Generated PDF certificate file', null=True, upload_to='certificates/pdf/%Y/%m/')),
                ('file_image', models.ImageField(blank=True, help_text='Generated PNG/JPEG certificate image', null=True, upload_to='certificates/images/%Y/%m/')),
                ('verification_code', models.UUIDField(db_index=True, default=uuid.uuid4, editable=False, help_text='Unique verification code (UUID4) for public verification', unique=True)),
                ('certificate_hash', models.CharField(help_text='SHA-256 hash of PDF file for tamper detection (64 hex characters)', max_length=64)),
                ('generated_at', models.DateTimeField(auto_now_add=True, help_text='When certificate was generated')),
                ('downloaded_at', models.DateTimeField(blank=True, help_text='First download timestamp', null=True)),
                ('download_count', models.PositiveIntegerField(default=0, help_text='Number of times certificate has been downloaded')),
                ('revoked_at', models.DateTimeField(blank=True, help_text='When certificate was revoked (if applicable)', null=True)),
                ('revoked_reason', models.TextField(blank=True, default='', help_text="Reason for revocation (e.g., 'Result disputed and changed', 'Regenerated with corrections')")),
                ('migrated_to_s3_at', models.DateTimeField(blank=True, help_text='When certificate files were migrated to S3 (backfill tracking)', null=True)),
                ('participant', models.ForeignKey(help_text='Participant who received this certificate (via Registration)', on_delete=django.db.models.deletion.CASCADE, related_name='certificates', to='tournaments.registration')),
                ('tournament', models.ForeignKey(help_text='Tournament this certificate was awarded for', on_delete=django.db.models.deletion.CASCADE, related_name='certificates', to='tournaments.tournament')),
            ],
            options={
                'verbose_name': 'Certificate',
                'verbose_name_plural': 'Certificates',
                'db_table': 'tournament_engine_certificate_certificate',
                'ordering': ['-generated_at'],
            },
        ),
        migrations.AddField(
            model_name='bracket',
            name='tournament',
            field=models.OneToOneField(help_text='Tournament this bracket belongs to', on_delete=django.db.models.deletion.CASCADE, related_name='bracket', to='tournaments.tournament', verbose_name='Tournament'),
        ),
        migrations.CreateModel(
            name='TournamentResult',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_deleted', models.BooleanField(db_index=True, default=False, help_text='Flag indicating if this record has been soft-deleted')),
                ('deleted_at', models.DateTimeField(blank=True, help_text='Timestamp when this record was deleted', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True, help_text='Timestamp when this record was created')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Timestamp when this record was last updated')),
                ('determination_method', models.CharField(choices=[('normal', 'Normal Bracket Resolution'), ('tiebreaker', 'Tie-Breaking Rules Applied'), ('forfeit_chain', 'Forfeit Chain Winner'), ('manual', 'Manual Organizer Selection')], default='normal', help_text='Method used to determine winner', max_length=20)),
                ('rules_applied', models.JSONField(default=dict, help_text='JSONB audit trail of determination logic. Contains ordered list of rules applied, intermediate scores, and reasoning for winner selection.')),
                ('requires_review', models.BooleanField(default=False, help_text='Flag indicating organizer review needed (e.g., forfeit chain, tie-breaking failures)')),
                ('is_override', models.BooleanField(default=False, help_text='Whether this placement was manually overridden by staff')),
                ('override_reason', models.TextField(blank=True, help_text='Reason for manual override (required if is_override=True)')),
                ('override_timestamp', models.DateTimeField(blank=True, help_text='When the override was applied', null=True)),
                ('total_kills', models.IntegerField(default=0, help_text='Total kills across all matches (BR games)')),
                ('best_placement', models.IntegerField(blank=True, help_text='Best placement achieved (BR games, 1=1st place)', null=True)),
                ('avg_placement', models.DecimalField(blank=True, decimal_places=2, help_text='Average placement (BR games)', max_digits=5, null=True)),
                ('matches_played', models.IntegerField(default=0, help_text='Number of matches played')),
                ('series_score', models.JSONField(blank=True, default=dict, help_text='Series score breakdown. Example: {"team-123": 2, "team-456": 1} for Best-of-3')),
                ('game_results', models.JSONField(blank=True, default=list, help_text='Individual game results in series. Example: [{"match_id": 1, "winner_id": "team-123", "score": {...}}, ...]')),
                ('created_by', models.ForeignKey(blank=True, help_text='User who triggered determination (or verified manually)', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='created_tournament_results', to=settings.AUTH_USER_MODEL)),
                ('deleted_by', models.ForeignKey(blank=True, help_text='User who deleted this record', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='%(class)s_deletions', to=settings.AUTH_USER_MODEL)),
                ('final_bracket', models.ForeignKey(blank=True, help_text='Bracket used for determination', null=True, on_delete=django.db.models.deletion.SET_NULL, to='tournaments.bracket')),
                ('override_actor', models.ForeignKey(blank=True, help_text='Staff member who performed the override', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='tournament_result_overrides', to=settings.AUTH_USER_MODEL)),
                ('runner_up', models.ForeignKey(blank=True, help_text='Second place participant', null=True, on_delete=django.db.models.deletion.PROTECT, related_name='runner_up_tournaments', to='tournaments.registration')),
                ('third_place', models.ForeignKey(blank=True, help_text='Third place participant (if applicable)', null=True, on_delete=django.db.models.deletion.PROTECT, related_name='third_place_tournaments', to='tournaments.registration')),
                ('tournament', models.OneToOneField(help_text='Tournament this result belongs to', on_delete=django.db.models.deletion.CASCADE, related_name='result', to='tournaments.tournament')),
                ('winner', models.ForeignKey(help_text='Winner participant (Registration record)', on_delete=django.db.models.deletion.PROTECT, related_name='won_tournaments', to='tournaments.registration')),
            ],
            options={
                'verbose_name': 'Tournament Result',
                'verbose_name_plural': 'Tournament Results',
                'db_table': 'tournament_engine_result_tournamentresult',
                'ordering': ['-created_at'],
            },
        ),
        migrations.CreateModel(
            name='TournamentTemplate',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_deleted', models.BooleanField(db_index=True, default=False, help_text='Flag indicating if this record has been soft-deleted')),
                ('deleted_at', models.DateTimeField(blank=True, help_text='Timestamp when this record was deleted', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True, help_text='Timestamp when this record was created')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Timestamp when this record was last updated')),
                ('name', models.CharField(help_text='Template name (e.g., "5v5 Valorant Tournament")', max_length=200)),
                ('slug', models.SlugField(help_text='URL-friendly slug (auto-generated from name)', max_length=250, unique=True)),
                ('description', models.TextField(blank=True, help_text='Template description and notes')),
                ('visibility', models.CharField(choices=[('private', 'Private (Creator Only)'), ('org', 'Organization'), ('global', 'Global (Public)')], db_index=True, default='private', help_text='Who can see and use this template', max_length=20)),
                ('organization_id', models.PositiveIntegerField(blank=True, db_index=True, help_text='Organization ID from DeltaCrown organizations app (no ForeignKey)', null=True)),
                ('template_config', models.JSONField(default=dict, help_text='Tournament configuration template (JSONB). Structure:\n        {\n            "format": "single_elimination",\n            "participation_type": "team",\n            "max_participants": 16,\n            "min_participants": 4,\n            "has_entry_fee": true,\n            "entry_fee_amount": "500.00",\n            "entry_fee_currency": "BDT",\n            "entry_fee_deltacoin": 0,\n            "payment_methods": ["bkash", "nagad", "deltacoin"],\n            "prize_pool": "10000.00",\n            "prize_currency": "BDT",\n            "prize_deltacoin": 0,\n            "prize_distribution": {"1": "50%", "2": "30%", "3": "20%"},\n            "enable_check_in": true,\n            "check_in_minutes_before": 15,\n            "enable_dynamic_seeding": false,\n            "enable_live_updates": true,\n            "enable_certificates": true,\n            "enable_fee_waiver": false,\n            "fee_waiver_top_n_teams": 0,\n            "custom_fields": [\n                {\n                    "field_name": "Discord Server",\n                    "field_type": "url",\n                    "is_required": true,\n                    "field_config": {"pattern": "^https://discord\\.gg/"}\n                }\n            ],\n            "match_settings": {\n                "default_best_of": 1,\n                "auto_schedule_matches": false,\n                "match_duration_minutes": 60\n            }\n        }\n        ')),
                ('usage_count', models.PositiveIntegerField(default=0, help_text='Number of times this template has been applied')),
                ('last_used_at', models.DateTimeField(blank=True, help_text='When this template was last used', null=True)),
                ('is_active', models.BooleanField(db_index=True, default=True, help_text='Whether this template is active (can be used)')),
                ('created_by', models.ForeignKey(help_text='User who created this template', on_delete=django.db.models.deletion.CASCADE, related_name='tournament_templates', to=settings.AUTH_USER_MODEL)),
                ('deleted_by', models.ForeignKey(blank=True, help_text='User who deleted this record', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='%(class)s_deletions', to=settings.AUTH_USER_MODEL)),
                ('game', models.ForeignKey(blank=True, help_text='Game for this template (null = multi-game)', null=True, on_delete=django.db.models.deletion.PROTECT, related_name='templates', to='tournaments.game')),
            ],
            options={
                'verbose_name': 'Tournament Template',
                'verbose_name_plural': 'Tournament Templates',
                'db_table': 'tournaments_tournamenttemplate',
                'ordering': ['-created_at'],
            },
        ),
        migrations.CreateModel(
            name='TournamentVersion',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('version_number', models.PositiveIntegerField(help_text='Sequential version number')),
                ('version_data', models.JSONField(help_text='Complete tournament configuration at this version')),
                ('change_summary', models.TextField(help_text='Human-readable summary of changes')),
                ('changed_at', models.DateTimeField(auto_now_add=True, help_text='When this version was created')),
                ('is_active', models.BooleanField(default=True, help_text='Whether this version is the active one')),
                ('rolled_back_at', models.DateTimeField(blank=True, help_text='When this version was rolled back to', null=True)),
                ('changed_by', models.ForeignKey(help_text='User who made this change', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='tournament_version_changes', to=settings.AUTH_USER_MODEL)),
                ('rolled_back_by', models.ForeignKey(blank=True, help_text='User who performed the rollback', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='tournament_version_rollbacks', to=settings.AUTH_USER_MODEL)),
                ('tournament', models.ForeignKey(help_text='Tournament this version belongs to', on_delete=django.db.models.deletion.CASCADE, related_name='versions', to='tournaments.tournament')),
            ],
            options={
                'verbose_name': 'Tournament Version',
                'verbose_name_plural': 'Tournament Versions',
                'ordering': ['-version_number'],
            },
        ),
        migrations.CreateModel(
            name='AuditLog',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('action', models.CharField(db_index=True, help_text='Action type (e.g., payment_verify, bracket_regenerate)', max_length=50)),
                ('timestamp', models.DateTimeField(auto_now_add=True, db_index=True, help_text='When the action occurred')),
                ('metadata', models.JSONField(default=dict, help_text='Action-specific data (tournament_id, payment_id, etc.)')),
                ('ip_address', models.GenericIPAddressField(blank=True, help_text='IP address of user', null=True)),
                ('user_agent', models.TextField(blank=True, help_text='User agent string from request', null=True)),
                ('user', models.ForeignKey(blank=True, help_text='User who performed the action (null if system action)', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='audit_logs', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Audit Log Entry',
                'verbose_name_plural': 'Audit Log Entries',
                'ordering': ['-timestamp'],
                'indexes': [models.Index(fields=['action', 'timestamp'], name='tournaments_action_39ba8c_idx'), models.Index(fields=['user', 'timestamp'], name='tournaments_user_id_2867cc_idx')],
            },
        ),
        migrations.CreateModel(
            name='Dispute',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, help_text='Timestamp when this record was created')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Timestamp when this record was last updated')),
                ('initiated_by_id', models.PositiveIntegerField(help_text='User ID who initiated the dispute', verbose_name='Initiated By ID')),
                ('reason', models.CharField(choices=[('score_mismatch', 'Score Mismatch'), ('no_show', 'No Show'), ('cheating', 'Cheating Accusation'), ('technical_issue', 'Technical Issue'), ('other', 'Other')], help_text='Reason for dispute', max_length=30, verbose_name='Reason')),
                ('description', models.TextField(help_text='Detailed description of the dispute', verbose_name='Description')),
                ('evidence_screenshot', models.ImageField(blank=True, help_text='Screenshot evidence for dispute', null=True, upload_to='disputes/evidence/', verbose_name='Evidence Screenshot')),
                ('evidence_video_url', models.URLField(blank=True, help_text='YouTube/Twitch URL with video evidence', verbose_name='Evidence Video URL')),
                ('status', models.CharField(choices=[('open', 'Open'), ('under_review', 'Under Review'), ('resolved', 'Resolved'), ('escalated', 'Escalated to Admin')], db_index=True, default='open', help_text='Current dispute status', max_length=20, verbose_name='Status')),
                ('resolved_by_id', models.PositiveIntegerField(blank=True, help_text='User ID who resolved the dispute (organizer or admin)', null=True, verbose_name='Resolved By ID')),
                ('resolution_notes', models.TextField(blank=True, help_text='Organizer/admin notes on resolution', verbose_name='Resolution Notes')),
                ('final_participant1_score', models.PositiveIntegerField(blank=True, help_text='Final score for participant 1 after resolution', null=True, validators=[django.core.validators.MinValueValidator(0)], verbose_name='Final Participant 1 Score')),
                ('final_participant2_score', models.PositiveIntegerField(blank=True, help_text='Final score for participant 2 after resolution', null=True, validators=[django.core.validators.MinValueValidator(0)], verbose_name='Final Participant 2 Score')),
                ('resolved_at', models.DateTimeField(blank=True, help_text='When dispute was resolved', null=True, verbose_name='Resolved At')),
                ('match', models.ForeignKey(help_text='Match this dispute is about', on_delete=django.db.models.deletion.CASCADE, related_name='disputes', to='tournaments.match', verbose_name='Match')),
            ],
            options={
                'verbose_name': 'Dispute',
                'verbose_name_plural': 'Disputes',
                'db_table': 'tournament_engine_match_dispute',
                'ordering': ['-created_at'],
                'indexes': [models.Index(fields=['match', 'status'], name='idx_dispute_match_status'), models.Index(fields=['status', 'created_at'], name='idx_dispute_status_created'), models.Index(fields=['reason'], name='idx_dispute_reason')],
                'constraints': [models.CheckConstraint(condition=models.Q(('reason__in', ['score_mismatch', 'no_show', 'cheating', 'technical_issue', 'other'])), name='chk_dispute_reason_valid'), models.CheckConstraint(condition=models.Q(('status__in', ['open', 'under_review', 'resolved', 'escalated'])), name='chk_dispute_status_valid')],
            },
        ),
        migrations.CreateModel(
            name='BracketNode',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('position', models.PositiveIntegerField(help_text='Sequential position in bracket (1-indexed)', verbose_name='Position')),
                ('round_number', models.PositiveIntegerField(help_text='Round number (1 = first round)', verbose_name='Round Number')),
                ('match_number_in_round', models.PositiveIntegerField(help_text='Match number within this round (1-indexed)', verbose_name='Match Number in Round')),
                ('participant1_id', models.IntegerField(blank=True, help_text='Team or User ID for participant 1', null=True, verbose_name='Participant 1 ID')),
                ('participant1_name', models.CharField(blank=True, help_text='Cached name for participant 1', max_length=100, verbose_name='Participant 1 Name')),
                ('participant2_id', models.IntegerField(blank=True, help_text='Team or User ID for participant 2', null=True, verbose_name='Participant 2 ID')),
                ('participant2_name', models.CharField(blank=True, help_text='Cached name for participant 2', max_length=100, verbose_name='Participant 2 Name')),
                ('winner_id', models.IntegerField(blank=True, help_text='Team or User ID of winner', null=True, verbose_name='Winner ID')),
                ('parent_slot', models.PositiveSmallIntegerField(blank=True, help_text='Which participant slot in parent match (1 or 2)', null=True, verbose_name='Parent Slot')),
                ('is_bye', models.BooleanField(default=False, help_text='Whether this is a bye match (participant advances without playing)', verbose_name='Is Bye')),
                ('bracket_type', models.CharField(default='main', help_text='Bracket type (main, losers, third-place, or group-N)', max_length=50, verbose_name='Bracket Type')),
                ('bracket', models.ForeignKey(help_text='Bracket this node belongs to', on_delete=django.db.models.deletion.CASCADE, related_name='nodes', to='tournaments.bracket', verbose_name='Bracket')),
                ('child1_node', models.ForeignKey(blank=True, help_text='Previous match for participant 1', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to='tournaments.bracketnode', verbose_name='Child 1 Node')),
                ('child2_node', models.ForeignKey(blank=True, help_text='Previous match for participant 2', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to='tournaments.bracketnode', verbose_name='Child 2 Node')),
                ('parent_node', models.ForeignKey(blank=True, help_text='Next match where winner advances', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='children', to='tournaments.bracketnode', verbose_name='Parent Node')),
                ('match', models.OneToOneField(blank=True, help_text='Associated match for this bracket position', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='bracket_node', to='tournaments.match', verbose_name='Match')),
            ],
            options={
                'verbose_name': 'Bracket Node',
                'verbose_name_plural': 'Bracket Nodes',
                'db_table': 'tournament_engine_bracket_bracketnode',
                'indexes': [models.Index(fields=['bracket'], name='idx_bracketnode_bracket'), models.Index(fields=['bracket', 'round_number'], name='idx_bracketnode_round'), models.Index(fields=['position'], name='idx_bracketnode_position'), models.Index(fields=['match'], name='idx_bracketnode_match'), models.Index(fields=['parent_node'], name='idx_bracketnode_parent'), models.Index(fields=['bracket', 'child1_node', 'child2_node'], name='idx_bracketnode_children'), models.Index(fields=['participant1_id', 'participant2_id'], name='idx_bracketnode_participants')],
                'constraints': [models.UniqueConstraint(fields=('bracket', 'position'), name='uq_bracketnode_bracket_position'), models.CheckConstraint(condition=models.Q(('round_number__gt', 0)), name='chk_bracketnode_round_positive'), models.CheckConstraint(condition=models.Q(('match_number_in_round__gt', 0)), name='chk_bracketnode_match_number_positive'), models.CheckConstraint(condition=models.Q(('parent_slot__isnull', True), ('parent_slot__in', [1, 2]), _connector='OR'), name='chk_bracketnode_parent_slot')],
            },
        ),
        migrations.CreateModel(
            name='Payment',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('payment_method', models.CharField(choices=[('bkash', 'bKash'), ('nagad', 'Nagad'), ('rocket', 'Rocket'), ('bank', 'Bank Transfer'), ('deltacoin', 'DeltaCoin')], help_text='Payment method used', max_length=20)),
                ('amount', models.DecimalField(decimal_places=2, help_text='Payment amount in BDT', max_digits=10)),
                ('transaction_id', models.CharField(blank=True, default='', help_text='Transaction ID from payment provider', max_length=200)),
                ('payment_proof', models.FileField(blank=True, help_text='Payment proof file upload (image or PDF, max 5MB)', null=True, upload_to='payment_proofs/%Y/%m/')),
                ('file_type', models.CharField(blank=True, choices=[('IMAGE', 'Image'), ('PDF', 'PDF Document')], default='', help_text='Type of uploaded proof file', max_length=10)),
                ('reference_number', models.CharField(blank=True, default='', help_text='Payment reference number from receipt', max_length=100)),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('submitted', 'Submitted'), ('verified', 'Verified'), ('rejected', 'Rejected'), ('refunded', 'Refunded')], db_index=True, default='pending', help_text='Current payment status', max_length=20)),
                ('admin_notes', models.TextField(blank=True, default='', help_text='Admin notes for verification/rejection')),
                ('verified_at', models.DateTimeField(blank=True, help_text='When payment was verified/rejected', null=True)),
                ('submitted_at', models.DateTimeField(auto_now_add=True, help_text='When payment proof was submitted')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Last update timestamp')),
                ('verified_by', models.ForeignKey(blank=True, help_text='Admin who verified/rejected the payment', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='verified_payments', to=settings.AUTH_USER_MODEL)),
                ('registration', models.OneToOneField(help_text='Associated registration', on_delete=django.db.models.deletion.CASCADE, related_name='payment', to='tournaments.registration')),
            ],
            options={
                'verbose_name': 'Payment',
                'verbose_name_plural': 'Payments',
                'db_table': 'tournaments_payment',
                'indexes': [models.Index(fields=['registration'], name='tournaments_registr_e9e4b4_idx'), models.Index(fields=['payment_method', 'status'], name='tournaments_payment_2b7bd6_idx'), models.Index(fields=['status', '-submitted_at'], name='tournaments_status_51a576_idx'), models.Index(fields=['verified_by', 'verified_at'], name='tournaments_verifie_c340c8_idx')],
                'constraints': [models.CheckConstraint(condition=models.Q(('amount__gt', 0)), name='payment_amount_positive'), models.CheckConstraint(condition=models.Q(('payment_method__in', ['bkash', 'nagad', 'rocket', 'bank', 'deltacoin'])), name='payment_method_valid'), models.CheckConstraint(condition=models.Q(('status__in', ['pending', 'submitted', 'verified', 'rejected', 'refunded'])), name='payment_status_valid'), models.CheckConstraint(condition=models.Q(models.Q(('status', 'verified'), ('verified_at__isnull', False), ('verified_by__isnull', False)), models.Q(('status', 'verified'), _negated=True), _connector='OR'), name='payment_verification_complete')],
            },
        ),
        migrations.AddIndex(
            model_name='tournament',
            index=models.Index(fields=['status', 'tournament_start'], name='tournaments_status_bdcbab_idx'),
        ),
        migrations.AddIndex(
            model_name='tournament',
            index=models.Index(fields=['game', 'status'], name='tournaments_game_id_c3d078_idx'),
        ),
        migrations.AddIndex(
            model_name='tournament',
            index=models.Index(fields=['organizer', 'status'], name='tournaments_organiz_e7ca48_idx'),
        ),
        migrations.AddIndex(
            model_name='tournament',
            index=models.Index(fields=['slug'], name='tournaments_slug_2e3c0a_idx'),
        ),
        migrations.AddIndex(
            model_name='tournament',
            index=models.Index(fields=['is_official', 'tournament_start'], name='tournaments_is_offi_24a3c6_idx'),
        ),
        migrations.AddConstraint(
            model_name='tournament',
            constraint=models.CheckConstraint(condition=models.Q(('min_participants__gte', 2)), name='min_participants_at_least_2'),
        ),
        migrations.AddConstraint(
            model_name='tournament',
            constraint=models.CheckConstraint(condition=models.Q(('max_participants__gte', models.F('min_participants'))), name='max_participants_gte_min_participants'),
        ),
        migrations.AddIndex(
            model_name='registration',
            index=models.Index(fields=['tournament', 'status'], name='tournaments_tournam_c14717_idx'),
        ),
        migrations.AddIndex(
            model_name='registration',
            index=models.Index(fields=['user', '-created_at'], name='tournaments_user_id_fa73e9_idx'),
        ),
        migrations.AddIndex(
            model_name='registration',
            index=models.Index(fields=['team_id', '-created_at'], name='tournaments_team_id_ca35f6_idx'),
        ),
        migrations.AddIndex(
            model_name='registration',
            index=models.Index(fields=['status', 'registered_at'], name='tournaments_status_f855db_idx'),
        ),
        migrations.AddIndex(
            model_name='registration',
            index=models.Index(fields=['tournament', 'slot_number'], name='tournaments_tournam_951e51_idx'),
        ),
        migrations.AddConstraint(
            model_name='registration',
            constraint=models.CheckConstraint(condition=models.Q(models.Q(('team_id__isnull', True), ('user__isnull', False)), models.Q(('team_id__isnull', False), ('user__isnull', True)), _connector='OR'), name='registration_user_xor_team'),
        ),
        migrations.AddConstraint(
            model_name='registration',
            constraint=models.UniqueConstraint(condition=models.Q(('is_deleted', False), ('slot_number__isnull', False)), fields=('tournament', 'slot_number'), name='unique_slot_per_tournament'),
        ),
        migrations.AddConstraint(
            model_name='registration',
            constraint=models.UniqueConstraint(condition=models.Q(('is_deleted', False), ('team_id__isnull', False)), fields=('tournament', 'team_id'), name='unique_team_per_tournament'),
        ),
        migrations.AddConstraint(
            model_name='registration',
            constraint=models.CheckConstraint(condition=models.Q(('status__in', ['pending', 'payment_submitted', 'confirmed', 'rejected', 'cancelled', 'no_show'])), name='registration_valid_status'),
        ),
        migrations.AlterUniqueTogether(
            name='registration',
            unique_together={('tournament', 'user')},
        ),
        migrations.AddIndex(
            model_name='prizetransaction',
            index=models.Index(fields=['tournament', 'status'], name='prize_tournament_status_idx'),
        ),
        migrations.AddIndex(
            model_name='prizetransaction',
            index=models.Index(fields=['participant'], name='prize_participant_idx'),
        ),
        migrations.AddIndex(
            model_name='prizetransaction',
            index=models.Index(fields=['coin_transaction_id'], name='prize_coin_tx_idx'),
        ),
        migrations.AddConstraint(
            model_name='prizetransaction',
            constraint=models.CheckConstraint(condition=models.Q(('amount__gte', 0)), name='prize_amount_positive', violation_error_message='Prize amount must be non-negative'),
        ),
        migrations.AddConstraint(
            model_name='prizetransaction',
            constraint=models.UniqueConstraint(fields=('tournament', 'participant', 'placement'), name='unique_prize_per_participant_placement', violation_error_message='Participant can only receive one prize per placement per tournament'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(fields=['tournament'], name='idx_match_tournament'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(fields=['bracket'], name='idx_match_bracket'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(fields=['bracket', 'round_number'], name='idx_match_round'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(fields=['state'], name='idx_match_state'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(fields=['scheduled_time'], name='idx_match_scheduled'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(fields=['participant1_id', 'participant2_id'], name='idx_match_participants'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(fields=['winner_id'], name='idx_match_winner'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(condition=models.Q(('state', 'check_in')), fields=['check_in_deadline', 'state'], name='idx_match_check_in'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(condition=models.Q(('state', 'live')), fields=['tournament', 'state'], name='idx_match_live'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(fields=['lobby_info'], name='idx_match_lobby_gin'),
        ),
        migrations.AddConstraint(
            model_name='match',
            constraint=models.CheckConstraint(condition=models.Q(('state__in', ['scheduled', 'check_in', 'ready', 'live', 'pending_result', 'completed', 'disputed', 'forfeit', 'cancelled'])), name='chk_match_state_valid'),
        ),
        migrations.AddConstraint(
            model_name='match',
            constraint=models.CheckConstraint(condition=models.Q(('participant1_score__gte', 0), ('participant2_score__gte', 0)), name='chk_match_scores_positive'),
        ),
        migrations.AddConstraint(
            model_name='match',
            constraint=models.CheckConstraint(condition=models.Q(models.Q(('loser_id__isnull', False), ('state', 'completed'), ('winner_id__isnull', False)), models.Q(('state', 'completed'), _negated=True), _connector='OR'), name='chk_match_completed_has_winner'),
        ),
        migrations.AddConstraint(
            model_name='match',
            constraint=models.CheckConstraint(condition=models.Q(('round_number__gt', 0), ('match_number__gt', 0)), name='chk_match_numbers_positive'),
        ),
        migrations.AddIndex(
            model_name='customfield',
            index=models.Index(fields=['tournament', 'order'], name='tournaments_tournam_68e8eb_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='customfield',
            unique_together={('tournament', 'field_key')},
        ),
        migrations.AddIndex(
            model_name='certificate',
            index=models.Index(fields=['tournament', 'certificate_type'], name='tournament__tournam_2379ee_idx'),
        ),
        migrations.AddIndex(
            model_name='certificate',
            index=models.Index(fields=['participant'], name='tournament__partici_7878dd_idx'),
        ),
        migrations.AddIndex(
            model_name='certificate',
            index=models.Index(fields=['verification_code'], name='tournament__verific_700652_idx'),
        ),
        migrations.AddIndex(
            model_name='certificate',
            index=models.Index(fields=['revoked_at'], name='tournament__revoked_9ba592_idx'),
        ),
        migrations.AddConstraint(
            model_name='certificate',
            constraint=models.UniqueConstraint(condition=models.Q(('revoked_at__isnull', True)), fields=('tournament', 'participant', 'certificate_type'), name='unique_cert_per_type_per_participant'),
        ),
        migrations.AddIndex(
            model_name='bracket',
            index=models.Index(fields=['tournament'], name='idx_bracket_tournament'),
        ),
        migrations.AddIndex(
            model_name='bracket',
            index=models.Index(fields=['format'], name='idx_bracket_format'),
        ),
        migrations.AddIndex(
            model_name='bracket',
            index=django.contrib.postgres.indexes.GinIndex(fields=['bracket_structure'], name='idx_bracket_structure_gin'),
        ),
        migrations.AddIndex(
            model_name='tournamentresult',
            index=models.Index(fields=['tournament'], name='idx_result_tournament'),
        ),
        migrations.AddIndex(
            model_name='tournamentresult',
            index=models.Index(fields=['winner'], name='idx_result_winner'),
        ),
        migrations.AddIndex(
            model_name='tournamentresult',
            index=models.Index(fields=['determination_method'], name='idx_result_method'),
        ),
        migrations.AddIndex(
            model_name='tournamentresult',
            index=models.Index(fields=['requires_review'], name='idx_result_review'),
        ),
        migrations.AddIndex(
            model_name='tournamentresult',
            index=models.Index(fields=['created_at'], name='idx_result_created'),
        ),
        migrations.AddConstraint(
            model_name='tournamentresult',
            constraint=models.CheckConstraint(condition=models.Q(('runner_up', models.F('winner')), _negated=True), name='runner_up_not_winner'),
        ),
        migrations.AddConstraint(
            model_name='tournamentresult',
            constraint=models.CheckConstraint(condition=models.Q(('third_place__isnull', True), models.Q(models.Q(('third_place', models.F('winner')), _negated=True), models.Q(('third_place', models.F('runner_up')), _negated=True)), _connector='OR'), name='third_place_unique'),
        ),
        migrations.AddIndex(
            model_name='tournamenttemplate',
            index=models.Index(fields=['created_by', 'is_active'], name='template_creator_active_idx'),
        ),
        migrations.AddIndex(
            model_name='tournamenttemplate',
            index=models.Index(fields=['game', 'visibility'], name='template_game_visibility_idx'),
        ),
        migrations.AddIndex(
            model_name='tournamenttemplate',
            index=models.Index(fields=['visibility', 'is_active'], name='template_visibility_active_idx'),
        ),
        migrations.AddConstraint(
            model_name='tournamenttemplate',
            constraint=models.UniqueConstraint(condition=models.Q(('is_deleted', False)), fields=('created_by', 'game', 'name'), name='unique_template_per_creator_game_name'),
        ),
        migrations.AddIndex(
            model_name='tournamentversion',
            index=models.Index(fields=['tournament', '-version_number'], name='tournaments_tournam_2a9b1f_idx'),
        ),
        migrations.AddIndex(
            model_name='tournamentversion',
            index=models.Index(fields=['changed_at'], name='tournaments_changed_55b4d2_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='tournamentversion',
            unique_together={('tournament', 'version_number')},
        ),
    ]
