# Generated by Django 5.2.8 on 2025-11-07 13:37

import django.contrib.postgres.fields
import django.contrib.postgres.indexes
import django.core.validators
import django.db.models.deletion
from decimal import Decimal
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Bracket',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, help_text='Timestamp when this record was created')),
                ('format', models.CharField(choices=[('single-elimination', 'Single Elimination'), ('double-elimination', 'Double Elimination'), ('round-robin', 'Round Robin'), ('swiss', 'Swiss System'), ('group-stage', 'Group Stage')], default='single-elimination', help_text='Type of bracket structure', max_length=50, verbose_name='Bracket Format')),
                ('total_rounds', models.PositiveIntegerField(default=0, help_text='Total number of rounds in bracket', verbose_name='Total Rounds')),
                ('total_matches', models.PositiveIntegerField(default=0, help_text='Total number of matches in bracket', verbose_name='Total Matches')),
                ('bracket_structure', models.JSONField(blank=True, default=dict, help_text='JSONB tree structure metadata for bracket visualization', verbose_name='Bracket Structure')),
                ('seeding_method', models.CharField(choices=[('slot-order', 'Slot Order (First-Come-First-Served)'), ('random', 'Random Seeding'), ('ranked', 'Ranked Seeding'), ('manual', 'Manual Seeding')], default='slot-order', help_text='How participants are seeded into bracket', max_length=30, verbose_name='Seeding Method')),
                ('is_finalized', models.BooleanField(default=False, help_text='Whether bracket is locked and cannot be regenerated', verbose_name='Is Finalized')),
                ('generated_at', models.DateTimeField(auto_now_add=True, help_text='When bracket was initially generated', null=True, verbose_name='Generated At')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Last update timestamp', verbose_name='Updated At')),
            ],
            options={
                'verbose_name': 'Bracket',
                'verbose_name_plural': 'Brackets',
                'db_table': 'tournament_engine_bracket_bracket',
            },
        ),
        migrations.CreateModel(
            name='Game',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100, unique=True)),
                ('slug', models.SlugField(max_length=120, unique=True)),
                ('icon', models.ImageField(help_text='Game icon/logo image', upload_to='games/icons/')),
                ('default_team_size', models.PositiveIntegerField(choices=[(1, '1v1'), (2, '2v2'), (3, '3v3'), (4, '4v4'), (5, '5v5'), (0, 'Variable')], default=5, help_text='Default team size for this game')),
                ('profile_id_field', models.CharField(help_text="Field name in UserProfile (e.g., 'riot_id', 'steam_id')", max_length=50)),
                ('default_result_type', models.CharField(choices=[('map_score', 'Map Score (e.g., 13-11)'), ('best_of', 'Best of X'), ('point_based', 'Point Based')], default='map_score', help_text='How match results are recorded', max_length=20)),
                ('is_active', models.BooleanField(db_index=True, default=True, help_text='Whether this game is actively supported')),
                ('description', models.TextField(blank=True, help_text='Game description and notes')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'verbose_name': 'Game',
                'verbose_name_plural': 'Games',
                'ordering': ['name'],
                'indexes': [models.Index(fields=['slug'], name='tournaments_slug_d1de23_idx'), models.Index(fields=['is_active', 'name'], name='tournaments_is_acti_b1f275_idx')],
            },
        ),
        migrations.CreateModel(
            name='Tournament',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_deleted', models.BooleanField(db_index=True, default=False, help_text='Flag indicating if this record has been soft-deleted')),
                ('deleted_at', models.DateTimeField(blank=True, help_text='Timestamp when this record was deleted', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True, help_text='Timestamp when this record was created')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Timestamp when this record was last updated')),
                ('name', models.CharField(help_text='Tournament name', max_length=200)),
                ('slug', models.SlugField(max_length=250, unique=True)),
                ('description', models.TextField(help_text='Tournament description and overview')),
                ('is_official', models.BooleanField(db_index=True, default=False, help_text='Whether this is an official DeltaCrown tournament')),
                ('format', models.CharField(choices=[('single_elimination', 'Single Elimination'), ('double_elimination', 'Double Elimination'), ('round_robin', 'Round Robin'), ('swiss', 'Swiss'), ('group_playoff', 'Group Stage + Playoff')], default='single_elimination', help_text='Bracket format for the tournament', max_length=50)),
                ('participation_type', models.CharField(choices=[('team', 'Team'), ('solo', 'Solo/Individual')], default='team', help_text='Whether teams or individuals participate', max_length=20)),
                ('max_participants', models.PositiveIntegerField(help_text='Maximum number of participants/teams', validators=[django.core.validators.MinValueValidator(2), django.core.validators.MaxValueValidator(256)])),
                ('min_participants', models.PositiveIntegerField(default=2, help_text='Minimum participants needed to start', validators=[django.core.validators.MinValueValidator(2)])),
                ('registration_start', models.DateTimeField(help_text='When registration opens')),
                ('registration_end', models.DateTimeField(help_text='When registration closes')),
                ('tournament_start', models.DateTimeField(help_text='When tournament begins')),
                ('tournament_end', models.DateTimeField(blank=True, help_text='When tournament ends (set automatically)', null=True)),
                ('prize_pool', models.DecimalField(decimal_places=2, default=Decimal('0.00'), help_text='Total prize pool amount', max_digits=10, validators=[django.core.validators.MinValueValidator(Decimal('0.00'))])),
                ('prize_currency', models.CharField(default='BDT', help_text='Currency for prize pool (BDT, USD, etc.)', max_length=10)),
                ('prize_deltacoin', models.PositiveIntegerField(default=0, help_text='Prize pool in DeltaCoins')),
                ('prize_distribution', models.JSONField(blank=True, default=dict, help_text='Prize distribution by placement (JSONB): {"1": "50%", "2": "30%", "3": "20%"}')),
                ('has_entry_fee', models.BooleanField(default=False, help_text='Whether tournament has an entry fee')),
                ('entry_fee_amount', models.DecimalField(decimal_places=2, default=Decimal('0.00'), help_text='Entry fee amount', max_digits=10, validators=[django.core.validators.MinValueValidator(Decimal('0.00'))])),
                ('entry_fee_currency', models.CharField(default='BDT', help_text='Currency for entry fee', max_length=10)),
                ('entry_fee_deltacoin', models.PositiveIntegerField(default=0, help_text='Entry fee in DeltaCoins')),
                ('payment_methods', django.contrib.postgres.fields.ArrayField(base_field=models.CharField(choices=[('deltacoin', 'DeltaCoin'), ('bkash', 'bKash'), ('nagad', 'Nagad'), ('rocket', 'Rocket'), ('bank_transfer', 'Bank Transfer')], max_length=20), blank=True, default=list, help_text='Accepted payment methods', size=None)),
                ('enable_fee_waiver', models.BooleanField(default=False, help_text='Enable automatic fee waiver for top teams')),
                ('fee_waiver_top_n_teams', models.PositiveIntegerField(default=0, help_text='Number of top teams eligible for fee waiver')),
                ('banner_image', models.ImageField(blank=True, help_text='Tournament banner image', null=True, upload_to='tournaments/banners/')),
                ('thumbnail_image', models.ImageField(blank=True, help_text='Tournament thumbnail for listings', null=True, upload_to='tournaments/thumbnails/')),
                ('rules_pdf', models.FileField(blank=True, help_text='Tournament rules PDF file', null=True, upload_to='tournaments/rules/')),
                ('promo_video_url', models.URLField(blank=True, help_text='YouTube/Vimeo promo video URL')),
                ('stream_youtube_url', models.URLField(blank=True, help_text='Official YouTube stream URL')),
                ('stream_twitch_url', models.URLField(blank=True, help_text='Official Twitch stream URL')),
                ('enable_check_in', models.BooleanField(default=True, help_text='Require participants to check in before matches')),
                ('check_in_minutes_before', models.PositiveIntegerField(default=15, help_text='Check-in window duration in minutes')),
                ('enable_dynamic_seeding', models.BooleanField(default=False, help_text='Use team rankings for seeding instead of registration order')),
                ('enable_live_updates', models.BooleanField(default=True, help_text='Enable WebSocket live updates for spectators')),
                ('enable_certificates', models.BooleanField(default=True, help_text='Generate certificates for winners')),
                ('enable_challenges', models.BooleanField(default=False, help_text='Enable bonus challenges during tournament')),
                ('enable_fan_voting', models.BooleanField(default=False, help_text='Enable spectator voting/predictions')),
                ('rules_text', models.TextField(blank=True, help_text='Tournament rules in text format')),
                ('status', models.CharField(choices=[('draft', 'Draft'), ('pending_approval', 'Pending Approval'), ('published', 'Published'), ('registration_open', 'Registration Open'), ('registration_closed', 'Registration Closed'), ('live', 'Live'), ('completed', 'Completed'), ('cancelled', 'Cancelled'), ('archived', 'Archived')], db_index=True, default='draft', help_text='Current tournament status', max_length=30)),
                ('published_at', models.DateTimeField(blank=True, help_text='When tournament was published', null=True)),
                ('total_registrations', models.PositiveIntegerField(default=0, help_text='Total number of registrations')),
                ('total_matches', models.PositiveIntegerField(default=0, help_text='Total number of matches')),
                ('completed_matches', models.PositiveIntegerField(default=0, help_text='Number of completed matches')),
                ('meta_description', models.TextField(blank=True, help_text='Meta description for SEO')),
                ('meta_keywords', django.contrib.postgres.fields.ArrayField(base_field=models.CharField(max_length=50), blank=True, default=list, help_text='SEO keywords', size=None)),
                ('deleted_by', models.ForeignKey(blank=True, help_text='User who deleted this record', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='%(class)s_deletions', to=settings.AUTH_USER_MODEL)),
                ('game', models.ForeignKey(help_text='Game being played in this tournament', on_delete=django.db.models.deletion.PROTECT, related_name='tournaments', to='tournaments.game')),
                ('organizer', models.ForeignKey(help_text='User who created this tournament', on_delete=django.db.models.deletion.PROTECT, related_name='organized_tournaments', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Tournament',
                'verbose_name_plural': 'Tournaments',
                'ordering': ['-tournament_start'],
            },
        ),
        migrations.CreateModel(
            name='Registration',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_deleted', models.BooleanField(db_index=True, default=False, help_text='Flag indicating if this record has been soft-deleted')),
                ('deleted_at', models.DateTimeField(blank=True, help_text='Timestamp when this record was deleted', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True, help_text='Timestamp when this record was created')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Timestamp when this record was last updated')),
                ('team_id', models.IntegerField(blank=True, db_index=True, help_text='Team ID reference (for team tournaments, IntegerField to avoid circular dependency)', null=True)),
                ('registration_data', models.JSONField(blank=True, default=dict, help_text='JSON storage for participant data (game IDs, contact info, custom fields)')),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('payment_submitted', 'Payment Submitted'), ('confirmed', 'Confirmed'), ('rejected', 'Rejected'), ('cancelled', 'Cancelled'), ('no_show', 'No Show')], db_index=True, default='pending', help_text='Current registration status', max_length=20)),
                ('registered_at', models.DateTimeField(auto_now_add=True, help_text='When registration was submitted', null=True)),
                ('checked_in', models.BooleanField(default=False, help_text='Whether participant has checked in on tournament day')),
                ('checked_in_at', models.DateTimeField(blank=True, help_text='When participant checked in', null=True)),
                ('slot_number', models.IntegerField(blank=True, help_text='Bracket slot number (1-based index for bracket position)', null=True)),
                ('seed', models.IntegerField(blank=True, help_text='Seeding number for bracket generation (lower = higher seed)', null=True)),
                ('deleted_by', models.ForeignKey(blank=True, help_text='User who deleted this record', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='%(class)s_deletions', to=settings.AUTH_USER_MODEL)),
                ('user', models.ForeignKey(blank=True, help_text='User who registered (for solo tournaments or team captain)', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='tournament_registrations', to=settings.AUTH_USER_MODEL)),
                ('tournament', models.ForeignKey(help_text='Tournament being registered for', on_delete=django.db.models.deletion.CASCADE, related_name='registrations', to='tournaments.Tournament')),
            ],
            options={
                'verbose_name': 'Registration',
                'verbose_name_plural': 'Registrations',
                'db_table': 'tournaments_registration',
            },
        ),
        migrations.CreateModel(
            name='Match',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_deleted', models.BooleanField(db_index=True, default=False, help_text='Flag indicating if this record has been soft-deleted')),
                ('deleted_at', models.DateTimeField(blank=True, help_text='Timestamp when this record was deleted', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True, help_text='Timestamp when this record was created')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Timestamp when this record was last updated')),
                ('round_number', models.PositiveIntegerField(help_text='Round number in bracket (1 = first round)', validators=[django.core.validators.MinValueValidator(1)], verbose_name='Round Number')),
                ('match_number', models.PositiveIntegerField(help_text='Match number within round', validators=[django.core.validators.MinValueValidator(1)], verbose_name='Match Number')),
                ('participant1_id', models.PositiveIntegerField(blank=True, help_text='Team ID or User ID for participant 1', null=True, verbose_name='Participant 1 ID')),
                ('participant1_name', models.CharField(blank=True, help_text='Denormalized name for display', max_length=100, verbose_name='Participant 1 Name')),
                ('participant2_id', models.PositiveIntegerField(blank=True, help_text='Team ID or User ID for participant 2', null=True, verbose_name='Participant 2 ID')),
                ('participant2_name', models.CharField(blank=True, help_text='Denormalized name for display', max_length=100, verbose_name='Participant 2 Name')),
                ('state', models.CharField(choices=[('scheduled', 'Scheduled'), ('check_in', 'Check-in Open'), ('ready', 'Ready to Start'), ('live', 'Live/In Progress'), ('pending_result', 'Pending Result'), ('completed', 'Completed'), ('disputed', 'Disputed'), ('forfeit', 'Forfeit'), ('cancelled', 'Cancelled')], db_index=True, default='scheduled', help_text='Current state in match lifecycle', max_length=20, verbose_name='State')),
                ('participant1_score', models.PositiveIntegerField(default=0, help_text='Score for participant 1', validators=[django.core.validators.MinValueValidator(0)], verbose_name='Participant 1 Score')),
                ('participant2_score', models.PositiveIntegerField(default=0, help_text='Score for participant 2', validators=[django.core.validators.MinValueValidator(0)], verbose_name='Participant 2 Score')),
                ('winner_id', models.PositiveIntegerField(blank=True, db_index=True, help_text='Team ID or User ID of winner (set when match completed)', null=True, verbose_name='Winner ID')),
                ('loser_id', models.PositiveIntegerField(blank=True, help_text='Team ID or User ID of loser (set when match completed)', null=True, verbose_name='Loser ID')),
                ('lobby_info', models.JSONField(blank=True, default=dict, help_text='Game lobby details (map, server, lobby code, password, etc.). Example: {"game_mode": "Competitive", "map": "Haven", "lobby_code": "ABC123"}', verbose_name='Lobby Info')),
                ('stream_url', models.URLField(blank=True, help_text='Twitch/YouTube stream URL for spectators', verbose_name='Stream URL')),
                ('scheduled_time', models.DateTimeField(blank=True, db_index=True, help_text='When match is scheduled to start', null=True, verbose_name='Scheduled Time')),
                ('check_in_deadline', models.DateTimeField(blank=True, help_text='Deadline for participants to check in', null=True, verbose_name='Check-in Deadline')),
                ('participant1_checked_in', models.BooleanField(default=False, help_text='Whether participant 1 has checked in', verbose_name='Participant 1 Checked In')),
                ('participant2_checked_in', models.BooleanField(default=False, help_text='Whether participant 2 has checked in', verbose_name='Participant 2 Checked In')),
                ('started_at', models.DateTimeField(blank=True, help_text='When match actually started (state → LIVE)', null=True, verbose_name='Started At')),
                ('completed_at', models.DateTimeField(blank=True, help_text='When match was completed (state → COMPLETED)', null=True, verbose_name='Completed At')),
                ('bracket', models.ForeignKey(blank=True, help_text='Bracket this match belongs to (null for group stage)', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='matches', to='tournaments.bracket', verbose_name='Bracket')),
                ('deleted_by', models.ForeignKey(blank=True, help_text='User who deleted this record', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='%(class)s_deletions', to=settings.AUTH_USER_MODEL)),
                ('tournament', models.ForeignKey(help_text='Tournament this match belongs to', on_delete=django.db.models.deletion.CASCADE, related_name='matches', to='tournaments.Tournament', verbose_name='Tournament')),
            ],
            options={
                'verbose_name': 'Match',
                'verbose_name_plural': 'Matches',
                'db_table': 'tournament_engine_match_match',
                'ordering': ['tournament', 'round_number', 'match_number'],
            },
        ),
        migrations.CreateModel(
            name='CustomField',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('field_name', models.CharField(help_text='Display name of the field', max_length=100)),
                ('field_key', models.SlugField(help_text='Unique key for form field name', max_length=120)),
                ('field_type', models.CharField(choices=[('text', 'Text'), ('number', 'Number'), ('media', 'Media Upload'), ('toggle', 'Toggle (Yes/No)'), ('date', 'Date'), ('url', 'URL'), ('dropdown', 'Dropdown')], default='text', help_text='Type of field (text, number, etc.)', max_length=20)),
                ('field_config', models.JSONField(blank=True, default=dict, help_text='Field configuration (min_length, max_length, options, etc.)')),
                ('field_value', models.JSONField(blank=True, default=dict, help_text='Actual field value storage')),
                ('order', models.PositiveIntegerField(default=0, help_text='Display order (lower numbers first)')),
                ('is_required', models.BooleanField(default=False, help_text='Whether this field is required')),
                ('help_text', models.CharField(blank=True, help_text='Help text shown to users', max_length=200)),
                ('tournament', models.ForeignKey(help_text='Tournament this field belongs to', on_delete=django.db.models.deletion.CASCADE, related_name='custom_fields', to='tournaments.Tournament')),
            ],
            options={
                'verbose_name': 'Custom Field',
                'verbose_name_plural': 'Custom Fields',
                'ordering': ['order', 'field_name'],
            },
        ),
        migrations.AddField(
            model_name='bracket',
            name='tournament',
            field=models.OneToOneField(help_text='Tournament this bracket belongs to', on_delete=django.db.models.deletion.CASCADE, related_name='bracket', to='tournaments.Tournament', verbose_name='Tournament'),
        ),
        migrations.CreateModel(
            name='TournamentVersion',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('version_number', models.PositiveIntegerField(help_text='Sequential version number')),
                ('version_data', models.JSONField(help_text='Complete tournament configuration at this version')),
                ('change_summary', models.TextField(help_text='Human-readable summary of changes')),
                ('changed_at', models.DateTimeField(auto_now_add=True, help_text='When this version was created')),
                ('is_active', models.BooleanField(default=True, help_text='Whether this version is the active one')),
                ('rolled_back_at', models.DateTimeField(blank=True, help_text='When this version was rolled back to', null=True)),
                ('changed_by', models.ForeignKey(help_text='User who made this change', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='tournament_version_changes', to=settings.AUTH_USER_MODEL)),
                ('rolled_back_by', models.ForeignKey(blank=True, help_text='User who performed the rollback', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='tournament_version_rollbacks', to=settings.AUTH_USER_MODEL)),
                ('tournament', models.ForeignKey(help_text='Tournament this version belongs to', on_delete=django.db.models.deletion.CASCADE, related_name='versions', to='tournaments.Tournament')),
            ],
            options={
                'verbose_name': 'Tournament Version',
                'verbose_name_plural': 'Tournament Versions',
                'ordering': ['-version_number'],
            },
        ),
        migrations.CreateModel(
            name='Dispute',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, help_text='Timestamp when this record was created')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Timestamp when this record was last updated')),
                ('initiated_by_id', models.PositiveIntegerField(help_text='User ID who initiated the dispute', verbose_name='Initiated By ID')),
                ('reason', models.CharField(choices=[('score_mismatch', 'Score Mismatch'), ('no_show', 'No Show'), ('cheating', 'Cheating Accusation'), ('technical_issue', 'Technical Issue'), ('other', 'Other')], help_text='Reason for dispute', max_length=30, verbose_name='Reason')),
                ('description', models.TextField(help_text='Detailed description of the dispute', verbose_name='Description')),
                ('evidence_screenshot', models.ImageField(blank=True, help_text='Screenshot evidence for dispute', null=True, upload_to='disputes/evidence/', verbose_name='Evidence Screenshot')),
                ('evidence_video_url', models.URLField(blank=True, help_text='YouTube/Twitch URL with video evidence', verbose_name='Evidence Video URL')),
                ('status', models.CharField(choices=[('open', 'Open'), ('under_review', 'Under Review'), ('resolved', 'Resolved'), ('escalated', 'Escalated to Admin')], db_index=True, default='open', help_text='Current dispute status', max_length=20, verbose_name='Status')),
                ('resolved_by_id', models.PositiveIntegerField(blank=True, help_text='User ID who resolved the dispute (organizer or admin)', null=True, verbose_name='Resolved By ID')),
                ('resolution_notes', models.TextField(blank=True, help_text='Organizer/admin notes on resolution', verbose_name='Resolution Notes')),
                ('final_participant1_score', models.PositiveIntegerField(blank=True, help_text='Final score for participant 1 after resolution', null=True, validators=[django.core.validators.MinValueValidator(0)], verbose_name='Final Participant 1 Score')),
                ('final_participant2_score', models.PositiveIntegerField(blank=True, help_text='Final score for participant 2 after resolution', null=True, validators=[django.core.validators.MinValueValidator(0)], verbose_name='Final Participant 2 Score')),
                ('resolved_at', models.DateTimeField(blank=True, help_text='When dispute was resolved', null=True, verbose_name='Resolved At')),
                ('match', models.ForeignKey(help_text='Match this dispute is about', on_delete=django.db.models.deletion.CASCADE, related_name='disputes', to='tournaments.match', verbose_name='Match')),
            ],
            options={
                'verbose_name': 'Dispute',
                'verbose_name_plural': 'Disputes',
                'db_table': 'tournament_engine_match_dispute',
                'ordering': ['-created_at'],
                'indexes': [models.Index(fields=['match', 'status'], name='idx_dispute_match_status'), models.Index(fields=['status', 'created_at'], name='idx_dispute_status_created'), models.Index(fields=['reason'], name='idx_dispute_reason')],
                'constraints': [models.CheckConstraint(condition=models.Q(('reason__in', ['score_mismatch', 'no_show', 'cheating', 'technical_issue', 'other'])), name='chk_dispute_reason_valid'), models.CheckConstraint(condition=models.Q(('status__in', ['open', 'under_review', 'resolved', 'escalated'])), name='chk_dispute_status_valid')],
            },
        ),
        migrations.CreateModel(
            name='BracketNode',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('position', models.PositiveIntegerField(help_text='Sequential position in bracket (1-indexed)', verbose_name='Position')),
                ('round_number', models.PositiveIntegerField(help_text='Round number (1 = first round)', verbose_name='Round Number')),
                ('match_number_in_round', models.PositiveIntegerField(help_text='Match number within this round (1-indexed)', verbose_name='Match Number in Round')),
                ('participant1_id', models.IntegerField(blank=True, help_text='Team or User ID for participant 1', null=True, verbose_name='Participant 1 ID')),
                ('participant1_name', models.CharField(blank=True, help_text='Cached name for participant 1', max_length=100, verbose_name='Participant 1 Name')),
                ('participant2_id', models.IntegerField(blank=True, help_text='Team or User ID for participant 2', null=True, verbose_name='Participant 2 ID')),
                ('participant2_name', models.CharField(blank=True, help_text='Cached name for participant 2', max_length=100, verbose_name='Participant 2 Name')),
                ('winner_id', models.IntegerField(blank=True, help_text='Team or User ID of winner', null=True, verbose_name='Winner ID')),
                ('parent_slot', models.PositiveSmallIntegerField(blank=True, help_text='Which participant slot in parent match (1 or 2)', null=True, verbose_name='Parent Slot')),
                ('is_bye', models.BooleanField(default=False, help_text='Whether this is a bye match (participant advances without playing)', verbose_name='Is Bye')),
                ('bracket_type', models.CharField(default='main', help_text='Bracket type (main, losers, third-place, or group-N)', max_length=50, verbose_name='Bracket Type')),
                ('bracket', models.ForeignKey(help_text='Bracket this node belongs to', on_delete=django.db.models.deletion.CASCADE, related_name='nodes', to='tournaments.bracket', verbose_name='Bracket')),
                ('child1_node', models.ForeignKey(blank=True, help_text='Previous match for participant 1', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to='tournaments.bracketnode', verbose_name='Child 1 Node')),
                ('child2_node', models.ForeignKey(blank=True, help_text='Previous match for participant 2', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to='tournaments.bracketnode', verbose_name='Child 2 Node')),
                ('parent_node', models.ForeignKey(blank=True, help_text='Next match where winner advances', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='children', to='tournaments.bracketnode', verbose_name='Parent Node')),
                ('match', models.OneToOneField(blank=True, help_text='Associated match for this bracket position', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='bracket_node', to='tournaments.match', verbose_name='Match')),
            ],
            options={
                'verbose_name': 'Bracket Node',
                'verbose_name_plural': 'Bracket Nodes',
                'db_table': 'tournament_engine_bracket_bracketnode',
                'indexes': [models.Index(fields=['bracket'], name='idx_bracketnode_bracket'), models.Index(fields=['bracket', 'round_number'], name='idx_bracketnode_round'), models.Index(fields=['position'], name='idx_bracketnode_position'), models.Index(fields=['match'], name='idx_bracketnode_match'), models.Index(fields=['parent_node'], name='idx_bracketnode_parent'), models.Index(fields=['bracket', 'child1_node', 'child2_node'], name='idx_bracketnode_children'), models.Index(fields=['participant1_id', 'participant2_id'], name='idx_bracketnode_participants')],
                'constraints': [models.UniqueConstraint(fields=('bracket', 'position'), name='uq_bracketnode_bracket_position'), models.CheckConstraint(condition=models.Q(('round_number__gt', 0)), name='chk_bracketnode_round_positive'), models.CheckConstraint(condition=models.Q(('match_number_in_round__gt', 0)), name='chk_bracketnode_match_number_positive'), models.CheckConstraint(condition=models.Q(('parent_slot__isnull', True), ('parent_slot__in', [1, 2]), _connector='OR'), name='chk_bracketnode_parent_slot')],
            },
        ),
        migrations.CreateModel(
            name='Payment',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('payment_method', models.CharField(choices=[('bkash', 'bKash'), ('nagad', 'Nagad'), ('rocket', 'Rocket'), ('bank', 'Bank Transfer'), ('deltacoin', 'DeltaCoin')], help_text='Payment method used', max_length=20)),
                ('amount', models.DecimalField(decimal_places=2, help_text='Payment amount in BDT', max_digits=10)),
                ('transaction_id', models.CharField(blank=True, default='', help_text='Transaction ID from payment provider', max_length=200)),
                ('payment_proof', models.CharField(blank=True, default='', help_text='Path to payment proof image (e.g., screenshot)', max_length=200)),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('submitted', 'Submitted'), ('verified', 'Verified'), ('rejected', 'Rejected'), ('refunded', 'Refunded')], db_index=True, default='pending', help_text='Current payment status', max_length=20)),
                ('admin_notes', models.TextField(blank=True, default='', help_text='Admin notes for verification/rejection')),
                ('verified_at', models.DateTimeField(blank=True, help_text='When payment was verified/rejected', null=True)),
                ('submitted_at', models.DateTimeField(auto_now_add=True, help_text='When payment proof was submitted')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Last update timestamp')),
                ('verified_by', models.ForeignKey(blank=True, help_text='Admin who verified/rejected the payment', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='verified_payments', to=settings.AUTH_USER_MODEL)),
                ('registration', models.OneToOneField(help_text='Associated registration', on_delete=django.db.models.deletion.CASCADE, related_name='payment', to='tournaments.registration')),
            ],
            options={
                'verbose_name': 'Payment',
                'verbose_name_plural': 'Payments',
                'db_table': 'tournaments_payment',
                'indexes': [models.Index(fields=['registration'], name='tournaments_registr_e9e4b4_idx'), models.Index(fields=['payment_method', 'status'], name='tournaments_payment_2b7bd6_idx'), models.Index(fields=['status', '-submitted_at'], name='tournaments_status_51a576_idx'), models.Index(fields=['verified_by', 'verified_at'], name='tournaments_verifie_c340c8_idx')],
                'constraints': [models.CheckConstraint(condition=models.Q(('amount__gt', 0)), name='payment_amount_positive'), models.CheckConstraint(condition=models.Q(('payment_method__in', ['bkash', 'nagad', 'rocket', 'bank', 'deltacoin'])), name='payment_method_valid'), models.CheckConstraint(condition=models.Q(('status__in', ['pending', 'submitted', 'verified', 'rejected', 'refunded'])), name='payment_status_valid'), models.CheckConstraint(condition=models.Q(models.Q(('status', 'verified'), ('verified_at__isnull', False), ('verified_by__isnull', False)), models.Q(('status', 'verified'), _negated=True), _connector='OR'), name='payment_verification_complete')],
            },
        ),
        migrations.AddIndex(
            model_name='tournament',
            index=models.Index(fields=['status', 'tournament_start'], name='tournaments_status_bdcbab_idx'),
        ),
        migrations.AddIndex(
            model_name='tournament',
            index=models.Index(fields=['game', 'status'], name='tournaments_game_id_c3d078_idx'),
        ),
        migrations.AddIndex(
            model_name='tournament',
            index=models.Index(fields=['organizer', 'status'], name='tournaments_organiz_e7ca48_idx'),
        ),
        migrations.AddIndex(
            model_name='tournament',
            index=models.Index(fields=['slug'], name='tournaments_slug_2e3c0a_idx'),
        ),
        migrations.AddIndex(
            model_name='tournament',
            index=models.Index(fields=['is_official', 'tournament_start'], name='tournaments_is_offi_24a3c6_idx'),
        ),
        migrations.AddConstraint(
            model_name='tournament',
            constraint=models.CheckConstraint(condition=models.Q(('min_participants__gte', 2)), name='min_participants_at_least_2'),
        ),
        migrations.AddConstraint(
            model_name='tournament',
            constraint=models.CheckConstraint(condition=models.Q(('max_participants__gte', models.F('min_participants'))), name='max_participants_gte_min_participants'),
        ),
        migrations.AddIndex(
            model_name='registration',
            index=models.Index(fields=['tournament', 'status'], name='tournaments_tournam_c14717_idx'),
        ),
        migrations.AddIndex(
            model_name='registration',
            index=models.Index(fields=['user', '-created_at'], name='tournaments_user_id_fa73e9_idx'),
        ),
        migrations.AddIndex(
            model_name='registration',
            index=models.Index(fields=['team_id', '-created_at'], name='tournaments_team_id_ca35f6_idx'),
        ),
        migrations.AddIndex(
            model_name='registration',
            index=models.Index(fields=['status', 'registered_at'], name='tournaments_status_f855db_idx'),
        ),
        migrations.AddIndex(
            model_name='registration',
            index=models.Index(fields=['tournament', 'slot_number'], name='tournaments_tournam_951e51_idx'),
        ),
        migrations.AddConstraint(
            model_name='registration',
            constraint=models.CheckConstraint(condition=models.Q(models.Q(('team_id__isnull', True), ('user__isnull', False)), models.Q(('team_id__isnull', False), ('user__isnull', True)), _connector='OR'), name='registration_user_xor_team'),
        ),
        migrations.AddConstraint(
            model_name='registration',
            constraint=models.UniqueConstraint(condition=models.Q(('is_deleted', False), ('slot_number__isnull', False)), fields=('tournament', 'slot_number'), name='unique_slot_per_tournament'),
        ),
        migrations.AddConstraint(
            model_name='registration',
            constraint=models.CheckConstraint(condition=models.Q(('status__in', ['pending', 'payment_submitted', 'confirmed', 'rejected', 'cancelled', 'no_show'])), name='registration_valid_status'),
        ),
        migrations.AlterUniqueTogether(
            name='registration',
            unique_together={('tournament', 'user')},
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(fields=['tournament'], name='idx_match_tournament'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(fields=['bracket'], name='idx_match_bracket'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(fields=['bracket', 'round_number'], name='idx_match_round'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(fields=['state'], name='idx_match_state'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(fields=['scheduled_time'], name='idx_match_scheduled'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(fields=['participant1_id', 'participant2_id'], name='idx_match_participants'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(fields=['winner_id'], name='idx_match_winner'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(condition=models.Q(('state', 'check_in')), fields=['check_in_deadline', 'state'], name='idx_match_check_in'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(condition=models.Q(('state', 'live')), fields=['tournament', 'state'], name='idx_match_live'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(fields=['lobby_info'], name='idx_match_lobby_gin'),
        ),
        migrations.AddConstraint(
            model_name='match',
            constraint=models.CheckConstraint(condition=models.Q(('state__in', ['scheduled', 'check_in', 'ready', 'live', 'pending_result', 'completed', 'disputed', 'forfeit', 'cancelled'])), name='chk_match_state_valid'),
        ),
        migrations.AddConstraint(
            model_name='match',
            constraint=models.CheckConstraint(condition=models.Q(('participant1_score__gte', 0), ('participant2_score__gte', 0)), name='chk_match_scores_positive'),
        ),
        migrations.AddConstraint(
            model_name='match',
            constraint=models.CheckConstraint(condition=models.Q(models.Q(('loser_id__isnull', False), ('state', 'completed'), ('winner_id__isnull', False)), models.Q(('state', 'completed'), _negated=True), _connector='OR'), name='chk_match_completed_has_winner'),
        ),
        migrations.AddConstraint(
            model_name='match',
            constraint=models.CheckConstraint(condition=models.Q(('round_number__gt', 0), ('match_number__gt', 0)), name='chk_match_numbers_positive'),
        ),
        migrations.AddIndex(
            model_name='customfield',
            index=models.Index(fields=['tournament', 'order'], name='tournaments_tournam_68e8eb_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='customfield',
            unique_together={('tournament', 'field_key')},
        ),
        migrations.AddIndex(
            model_name='bracket',
            index=models.Index(fields=['tournament'], name='idx_bracket_tournament'),
        ),
        migrations.AddIndex(
            model_name='bracket',
            index=models.Index(fields=['format'], name='idx_bracket_format'),
        ),
        migrations.AddIndex(
            model_name='bracket',
            index=django.contrib.postgres.indexes.GinIndex(fields=['bracket_structure'], name='idx_bracket_structure_gin'),
        ),
        migrations.AddIndex(
            model_name='tournamentversion',
            index=models.Index(fields=['tournament', '-version_number'], name='tournaments_tournam_2a9b1f_idx'),
        ),
        migrations.AddIndex(
            model_name='tournamentversion',
            index=models.Index(fields=['changed_at'], name='tournaments_changed_55b4d2_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='tournamentversion',
            unique_together={('tournament', 'version_number')},
        ),
    ]
